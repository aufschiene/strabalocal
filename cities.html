<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Straba Städte</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f5f5f5;
      min-height: 100vh;
      color: #333;
      padding: 20px;
      padding-bottom: 120px;
    }
    
    .container { max-width: 500px; margin: 0 auto; }
    
    .header {
      text-align: center;
      margin-bottom: 24px;
    }
    .header h1 { font-size: 24px; margin-bottom: 8px; color: #333; }
    .header p { color: #666; font-size: 14px; }
    
    /* Breadcrumb */
    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 20px;
      font-size: 13px;
      flex-wrap: wrap;
    }
    .breadcrumb-item {
      color: #888;
      cursor: pointer;
      transition: color 0.2s;
    }
    .breadcrumb-item:hover { color: #0055a4; }
    .breadcrumb-item.active { color: #0055a4; font-weight: 600; cursor: default; }
    .breadcrumb-sep { color: #ccc; }
    
    /* Cards */
    .card {
      background: #fff;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid #e0e0e0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .card h2 {
      font-size: 16px;
      color: #333;
      margin-bottom: 16px;
    }
    
    /* Selection Grid */
    .selection-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
    }
    .selection-grid.single { grid-template-columns: 1fr; }
    
    .selection-btn {
      padding: 16px;
      border-radius: 12px;
      border: 2px solid #e0e0e0;
      background: #fff;
      color: #333;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    .selection-btn:hover {
      border-color: #0055a4;
      background: #f0f5fa;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .selection-btn .icon { font-size: 32px; margin-bottom: 8px; }
    .selection-btn .name { font-weight: 600; font-size: 15px; margin-bottom: 4px; color: #333; }
    .selection-btn .desc { font-size: 11px; color: #888; }
    
    /* Network Brand Colors */
    .network-badge {
      display: inline-block;
      padding: 8px 16px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 14px;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }
    .network-badge.wl { background: #E20613; color: #fff; }
    .network-badge.wlb { background: #1E4D8C; color: #fff; }
    .network-badge.linz { background: #009640; color: #fff; }
    .network-badge.db { background: #EC0016; color: #fff; }
    .network-badge.berlin { background: #F0AB00; color: #000; }
    .network-badge.bodo { background: #005BBB; color: #fff; }
    .network-badge.salzburg { background: #E3000F; color: #fff; }
    .network-badge.sbg { background: #E3000F; color: #fff; }
    
    /* Region badges */
    .region-badge {
      display: inline-block;
      width: 48px;
      height: 32px;
      border-radius: 6px;
      margin-bottom: 10px;
      line-height: 32px;
      font-weight: 700;
      font-size: 14px;
    }
    .region-badge.at { background: linear-gradient(180deg, #ED2939 33%, #fff 33%, #fff 66%, #ED2939 66%); }
    .region-badge.de { background: linear-gradient(180deg, #000 33%, #D00 33%, #D00 66%, #FC0 66%); }
    .region-badge.ch { background: #D52B1E; color: #fff; }
    .region-badge.dk { background: #C8102E; color: #fff; }
    
    .selection-btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .selection-btn.disabled:hover {
      border-color: #e0e0e0;
      background: #fff;
      transform: none;
      box-shadow: none;
    }
    
    /* Search */
    .search-container { position: relative; margin-bottom: 16px; }
    .search-input {
      width: 100%;
      padding: 16px 16px 16px 48px;
      border: 2px solid #e0e0e0;
      border-radius: 14px;
      background: #fff;
      color: #333;
      font-size: 16px;
      transition: all 0.2s;
    }
    .search-input:focus {
      outline: none;
      border-color: #0055a4;
      box-shadow: 0 0 0 3px rgba(0, 85, 164, 0.1);
    }
    .search-input::placeholder { color: #999; }
    .search-icon {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 18px;
      height: 18px;
      border: 2px solid #999;
      border-radius: 50%;
    }
    .search-icon::after {
      content: '';
      position: absolute;
      width: 2px;
      height: 6px;
      background: #999;
      bottom: -5px;
      right: -2px;
      transform: rotate(-45deg);
    }
    .search-spinner {
      position: absolute;
      right: 16px;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 20px;
      border: 2px solid rgba(0, 85, 164, 0.3);
      border-top-color: #0055a4;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }
    .search-spinner.show { display: block; }
    @keyframes spin { to { transform: translateY(-50%) rotate(360deg); } }
    
    /* Search Results */
    .search-results {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      max-height: 300px;
      overflow-y: auto;
      display: none;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    }
    .search-results.show { display: block; }
    .search-result-item {
      padding: 14px 16px;
      cursor: pointer;
      transition: all 0.15s;
      border-bottom: 1px solid #f0f0f0;
    }
    .search-result-item:last-child { border-bottom: none; }
    .search-result-item:hover { background: #f8f8f8; }
    .search-result-item .stop-name { font-weight: 600; font-size: 15px; margin-bottom: 4px; color: #333; }
    .search-result-item .stop-info { font-size: 12px; color: #888; }
    .no-results { padding: 20px; text-align: center; color: #888; }
    
    /* Lines Selection */
    .lines-container { margin-top: 16px; }
    .lines-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .lines-header h3 { font-size: 14px; color: #333; }
    .select-all-btn {
      font-size: 12px;
      color: #0055a4;
      background: none;
      border: none;
      cursor: pointer;
    }
    
    .line-group {
      margin-bottom: 16px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      overflow: hidden;
    }
    .line-group-header {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: #f8f8f8;
      border-bottom: 1px solid #e0e0e0;
    }
    .line-group-header .line-badge {
      padding: 6px 14px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 15px;
      min-width: 50px;
      text-align: center;
    }
    /* Tram/Straßenbahn - Rot */
    .line-badge.type-tram {
      background: #c41e3a;
      color: #fff;
    }
    /* Bus - Blau */
    .line-badge.type-bus {
      background: #0055a4;
      color: #fff;
    }
    /* U-Bahn - Schwarz mit weißer Schrift */
    .line-badge.type-metro {
      background: #1a1a1a;
      color: #fff;
    }
    /* S-Bahn - Grün */
    .line-badge.type-suburban {
      background: #006e34;
      color: #fff;
    }
    /* O-Bus / Trolleybus - Orange */
    .line-badge.type-obus {
      background: #e67700;
      color: #fff;
    }
    /* Regional/Zug - Weiß mit schwarzer Schrift */
    .line-badge.type-train {
      background: #fff;
      color: #1a1a1a;
      border: 2px solid #1a1a1a;
    }
    /* Default */
    .line-badge.type-default {
      background: #666;
      color: #fff;
    }
    
    .line-group-header .line-name {
      font-weight: 600;
      font-size: 14px;
      color: #333;
    }
    .line-group-header .line-toggle {
      margin-left: auto;
      font-size: 12px;
      color: #0055a4;
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px 8px;
    }
    .line-group-header .line-toggle:hover {
      text-decoration: underline;
    }
    
    .line-directions {
      padding: 4px 0;
    }
    
    .direction-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      cursor: pointer;
      transition: all 0.15s;
    }
    .direction-option:hover {
      background: #f8f8f8;
    }
    .direction-option.selected {
      background: #e8f0f8;
    }
    .direction-option .checkbox {
      width: 22px;
      height: 22px;
      border: 2px solid #ccc;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
      transition: all 0.15s;
    }
    .direction-option.selected .checkbox {
      background: #0055a4;
      border-color: #0055a4;
      color: #fff;
    }
    .direction-option .direction-text {
      font-size: 14px;
      color: #555;
    }
    .direction-option .direction-text::before {
      content: '→ ';
      color: #999;
    }
    
    .lines-loading {
      text-align: center;
      padding: 30px;
      color: #888;
    }
    .lines-loading .spinner {
      width: 32px;
      height: 32px;
      border: 3px solid #e0e0e0;
      border-top-color: #0055a4;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 12px;
    }
    
    /* Station Chips */
    .station-chip {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #e8f5e9;
      border: 1px solid #a5d6a7;
      border-radius: 12px;
      padding: 12px 14px;
      margin-bottom: 10px;
    }
    .station-chip.existing {
      background: #fff8e1;
      border-color: #ffe082;
    }
    .station-chip .network-badge {
      padding: 4px 10px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 12px;
      flex-shrink: 0;
    }
    /* Network colors - used by station chips */
    .station-chip .network-badge.wl { background: #E20613; color: #fff; }
    .station-chip .network-badge.wlb { background: #1E4D8C; color: #fff; }
    .station-chip .network-badge.linz { background: #009640; color: #fff; }
    .station-chip .network-badge.db { background: #EC0016; color: #fff; }
    .station-chip .network-badge.berlin { background: #F0AB00; color: #000; }
    .station-chip .network-badge.bodo { background: #005BBB; color: #fff; }
    .station-chip .network-badge.salzburg { background: #E3000F; color: #fff; }
    .station-chip .network-badge.sbg { background: #E3000F; color: #fff; }
    .station-chip .info { flex: 1; min-width: 0; }
    .station-chip .stop-name {
      font-weight: 600;
      font-size: 14px;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .station-chip .stop-details { font-size: 12px; color: #666; margin-top: 2px; }
    .station-chip .delete {
      background: #ffebee;
      border: none;
      color: #c62828;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    .station-chip .delete:hover { background: #ffcdd2; }
    .station-chip .edit {
      background: #e3f2fd;
      border: none;
      color: #1565c0;
      width: 32px;
      height: 32px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      margin-right: 6px;
    }
    .station-chip .edit:hover { background: #bbdefb; }
    .station-chip .buttons {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .empty-state {
      text-align: center;
      padding: 30px;
      color: #999;
    }
    .empty-state .icon { font-size: 48px; margin-bottom: 12px; }
    
    /* Buttons */
    .btn {
      width: 100%;
      padding: 14px;
      border: none;
      border-radius: 12px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .btn-primary {
      background: #0055a4;
      color: #fff;
    }
    .btn-primary:hover {
      background: #004080;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0, 85, 164, 0.3);
    }
    .btn-primary:disabled {
      background: #e0e0e0;
      color: #999;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    .btn-secondary {
      background: #f0f0f0;
      color: #333;
      margin-top: 12px;
    }
    .btn-secondary:hover { background: #e0e0e0; }
    
    /* Bottom Bar */
    .bottom-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #fff;
      border-top: 1px solid #e0e0e0;
      padding: 16px 20px;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
      z-index: 100;
    }
    .bottom-bar .container { max-width: 500px; }
    .btn-save {
      background: #0055a4;
      color: #fff;
    }
    .btn-save:hover { background: #004080; }
    .btn-save:disabled { background: #e0e0e0; color: #999; cursor: not-allowed; }
    
    /* Back Button */
    .back-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #666;
      font-size: 14px;
      background: none;
      border: none;
      cursor: pointer;
      margin-bottom: 16px;
      padding: 8px 0;
    }
    .back-btn::before {
      content: '';
      display: inline-block;
      width: 8px;
      height: 8px;
      border-left: 2px solid currentColor;
      border-bottom: 2px solid currentColor;
      transform: rotate(45deg);
      margin-right: 4px;
    }
    .back-btn:hover { color: #0055a4; }

    /* Hidden */
    .hidden { display: none !important; }
    .finetuning-step.hidden { display: none !important; }

    /* ==================== LINE GROUPING ==================== */
    .grouping-info {
      background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
      border: 1px solid #bbdefb;
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 20px;
    }
    .grouping-info-header {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }
    .grouping-info-header .icon {
      font-size: 24px;
    }
    .grouping-info-header h4 {
      font-size: 15px;
      color: #1565c0;
      margin: 0;
    }
    .grouping-info p {
      font-size: 13px;
      color: #555;
      margin: 0;
      line-height: 1.5;
    }
    .grouping-toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      padding: 14px 16px;
      margin-bottom: 16px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .grouping-toggle:hover {
      border-color: #0055a4;
      background: #f8f9fa;
    }
    .grouping-toggle.active {
      border-color: #0055a4;
      background: #e3f2fd;
    }
    .grouping-toggle-label {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .grouping-toggle-label .icon {
      font-size: 20px;
    }
    .grouping-toggle-label span {
      font-weight: 600;
      font-size: 14px;
      color: #333;
    }
    .grouping-toggle-switch {
      width: 48px;
      height: 26px;
      background: #ccc;
      border-radius: 13px;
      position: relative;
      transition: all 0.2s;
    }
    .grouping-toggle.active .grouping-toggle-switch {
      background: #0055a4;
    }
    .grouping-toggle-switch::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: #fff;
      border-radius: 50%;
      top: 2px;
      left: 2px;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .grouping-toggle.active .grouping-toggle-switch::after {
      left: 24px;
    }

    .grouping-container {
      border: 2px dashed #ccc;
      border-radius: 12px;
      padding: 16px;
      min-height: 120px;
      background: #fafafa;
      margin-bottom: 16px;
    }
    .grouping-container.drag-over {
      border-color: #0055a4;
      background: #e3f2fd;
    }

    .line-groups-area {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .custom-group {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
    }
    .custom-group-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: #f0f0f0;
      border-bottom: 1px solid #e0e0e0;
    }
    .custom-group-header .group-icon {
      font-size: 16px;
    }
    .custom-group-header .group-name {
      flex: 1;
      font-weight: 600;
      font-size: 13px;
      color: #333;
    }
    .custom-group-header .group-delete {
      background: none;
      border: none;
      color: #999;
      cursor: pointer;
      font-size: 16px;
      padding: 4px;
    }
    .custom-group-header .group-delete:hover {
      color: #c62828;
    }

    .group-lines-dropzone {
      min-height: 50px;
      padding: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .group-lines-dropzone.drag-over {
      background: #e8f5e9;
    }
    .group-lines-dropzone.empty::before {
      content: 'Linien hierher ziehen';
      color: #999;
      font-size: 12px;
      width: 100%;
      text-align: center;
      padding: 12px;
    }

    .draggable-line {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      cursor: grab;
      font-size: 13px;
      transition: all 0.15s;
      user-select: none;
    }
    .draggable-line:hover {
      border-color: #0055a4;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .draggable-line.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }
    .draggable-line .line-badge {
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 700;
      font-size: 11px;
      min-width: 28px;
      text-align: center;
    }

    /* Direction items (line + destination) */
    .draggable-line.direction-item {
      padding: 4px 8px;
    }
    .draggable-line .direction-arrow {
      color: #666;
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 140px;
    }

    .ungrouped-lines {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
    }
    .ungrouped-lines-header {
      font-size: 12px;
      color: #666;
      margin-bottom: 10px;
    }
    .ungrouped-lines-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 40px;
    }
    .ungrouped-lines-list.drag-over {
      background: #fff3e0;
    }

    .add-group-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      width: 100%;
      padding: 12px;
      border: 2px dashed #ccc;
      border-radius: 10px;
      background: transparent;
      color: #666;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .add-group-btn:hover {
      border-color: #0055a4;
      color: #0055a4;
      background: #f8f9fa;
    }

    /* Display Config Step */
    .config-suggestion {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .suggestion-header {
      margin-bottom: 15px;
    }
    .suggestion-label {
      font-size: 13px;
      color: #666;
    }
    .suggestion-preview {
      display: flex;
      gap: 15px;
      align-items: center;
      background: #fff;
      border-radius: 10px;
      padding: 15px;
      margin-bottom: 15px;
      border: 2px solid #0055a4;
    }
    .preview-image {
      width: 120px;
      height: 80px;
      background: #000;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
      position: relative;
    }
    .preview-image .line-preview {
      display: flex;
      flex-direction: column;
      gap: 4px;
      width: 100%;
      padding: 8px;
    }
    .preview-image .line-row {
      display: flex;
      align-items: center;
      gap: 6px;
      animation: slideIn 0.5s ease-out;
    }
    .preview-image .line-badge {
      font-size: 8px;
      font-weight: bold;
      padding: 2px 4px;
      border-radius: 2px;
      color: #fff;
    }
    .preview-image .line-dest {
      font-size: 7px;
      color: #fff;
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
    }
    .preview-image .line-time {
      font-size: 9px;
      color: #0f0;
      font-weight: bold;
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-10px); }
      to { opacity: 1; transform: translateX(0); }
    }
    .preview-info {
      flex: 1;
    }
    .preview-title {
      font-weight: 600;
      font-size: 16px;
      color: #333;
      margin-bottom: 4px;
    }
    .preview-desc {
      font-size: 13px;
      color: #666;
    }
    .suggestion-details {
      display: flex;
      gap: 20px;
    }
    .detail-row {
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .detail-label {
      font-size: 13px;
      color: #666;
    }
    .detail-value {
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    .config-actions {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .btn-large {
      padding: 16px 24px;
      font-size: 16px;
    }
    .finetuning-section {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #e0e0e0;
    }
    .finetuning-section h3 {
      font-size: 14px;
      color: #333;
      margin-bottom: 15px;
    }
    .finetuning-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 12px;
    }
    .finetuning-row label {
      min-width: 120px;
      font-size: 14px;
      color: #666;
    }
    .finetuning-row select {
      flex: 1;
      padding: 10px 12px;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      font-size: 14px;
      background: #fff;
      color: #333;
    }
    .finetuning-row select:focus {
      outline: none;
      border-color: #0055a4;
    }

    /* Journey Mode Styles */
    .journey-field {
      margin-bottom: 12px;
    }
    .journey-field label {
      display: block;
      font-size: 13px;
      color: #666;
      margin-bottom: 6px;
      font-weight: 600;
    }
    .journey-arrow {
      text-align: center;
      padding: 8px 0;
    }
    .journey-arrow::before {
      content: '';
      display: inline-block;
      width: 12px;
      height: 12px;
      border-right: 3px solid #ccc;
      border-bottom: 3px solid #ccc;
      transform: rotate(45deg);
    }
    
    .journey-selected {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 14px;
      background: #e8f0f8;
      border: 2px solid #0055a4;
      border-radius: 12px;
      margin-top: 8px;
    }
    .journey-selected .station-name {
      font-weight: 600;
      color: #333;
    }
    .journey-selected .change-btn {
      background: none;
      border: none;
      color: #0055a4;
      font-size: 13px;
      cursor: pointer;
    }
    .journey-selected .change-btn:hover {
      text-decoration: underline;
    }
    
    /* Product Selection */
    .journey-products {
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid #e0e0e0;
    }
    
    .product-category {
      margin-bottom: 12px;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      overflow: hidden;
    }
    .category-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: #f8f9fa;
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      color: #333;
    }
    .category-header:hover {
      background: #f0f2f4;
    }
    .category-toggle {
      color: #666;
      font-size: 12px;
      transition: transform 0.2s;
    }
    .category-content {
      background: #fff;
    }
    .category-content.collapsed {
      display: none;
    }
    
    .product-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      background: #fff;
      border-bottom: 1px solid #f0f0f0;
      cursor: pointer;
      transition: all 0.15s;
    }
    .product-option:last-child {
      border-bottom: none;
    }
    .product-option:hover {
      background: #f8f9fa;
    }
    .product-option.selected {
      background: #f0f5fa;
    }
    .product-option .checkbox {
      width: 24px;
      height: 24px;
      border: 2px solid #ccc;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }
    .product-option.selected .checkbox {
      background: #0055a4;
      border-color: #0055a4;
      color: #fff;
    }
    .product-option .product-badge {
      padding: 6px 14px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 14px;
      min-width: 50px;
      text-align: center;
      background: #1a1a1a;
      color: #fff;
    }
    .product-option .product-badge.ice { background: #fff; color: #1a1a1a; border: 2px solid #1a1a1a; }
    .product-option .product-badge.ic { background: #fff; color: #1a1a1a; border: 2px solid #1a1a1a; }
    .product-option .product-badge.rj { background: #c41e3a; color: #fff; }
    .product-option .product-badge.re { background: #006e34; color: #fff; }
    .product-option .product-badge.rb { background: #006e34; color: #fff; }
    .product-option .product-badge.s { background: #006e34; color: #fff; }
    .product-option .product-name {
      font-size: 14px;
      color: #333;
    }

    /* Success Button */
    .btn-success {
      background: #28a745 !important;
    }
    .btn-success:hover {
      background: #218838 !important;
    }

    /* Config Hint */
    .config-hint {
      text-align: center;
      font-size: 12px;
      color: #888;
      margin-top: 15px;
      line-height: 1.5;
    }

    /* Quick Settings Preview */
    .quick-settings-preview {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 15px;
      margin-top: 20px;
    }
    .quick-settings-preview h4 {
      font-size: 13px;
      color: #666;
      margin-bottom: 10px;
    }
    .settings-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .setting-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: #e8f0f8;
      border: 1px solid #c8d8e8;
      border-radius: 16px;
      padding: 4px 10px;
      font-size: 12px;
      color: #333;
    }
    .setting-tag.highlight {
      background: #d4edda;
      border-color: #a3d9b1;
    }
    .setting-tag.inactive {
      background: #f0f0f0;
      border-color: #ddd;
      color: #999;
    }

    /* Wien Options */
    .wien-options {
      background: #fff8e1;
      border: 1px solid #ffe082;
      border-radius: 10px;
      padding: 12px;
      margin-top: 12px;
    }
    .wien-options h4 {
      font-size: 12px;
      color: #f57c00;
      margin-bottom: 10px;
    }

    /* Gehweg Quick */
    .gehweg-quick {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #e0e0e0;
    }
    .gehweg-quick h4 {
      font-size: 13px;
      color: #333;
      margin-bottom: 6px;
    }
    .gehweg-hint {
      font-size: 11px;
      color: #888;
      margin-bottom: 10px;
    }
    .gehweg-quick-item {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
      padding: 8px 10px;
      background: #f8f8f8;
      border-radius: 8px;
    }
    .gehweg-quick-item .station-name {
      flex: 1;
      font-size: 13px;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .gehweg-quick-item input {
      width: 60px;
      padding: 6px 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 13px;
      text-align: center;
    }
    .gehweg-quick-item .unit {
      font-size: 12px;
      color: #888;
    }

    /* Realistic Display Preview */
    .realistic-display {
      font-family: 'Courier New', monospace;
    }
    .display-row {
      transition: all 0.3s ease;
    }

    /* ==================== FEINTUNING STEP - EINHEITLICHES HELLES DESIGN ==================== */
    .finetuning-step {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #f5f5f5;
      z-index: 1000;
      overflow-y: auto;
      padding: 20px;
      padding-bottom: 100px;
    }
    .finetuning-step .ft-container {
      max-width: 500px;
      margin: 0 auto;
    }
    .finetuning-step .header {
      text-align: center;
      margin-bottom: 24px;
    }
    .finetuning-step .header h1 {
      font-size: 24px;
      color: #333;
      margin-bottom: 8px;
    }
    .finetuning-step .header p {
      color: #666;
      font-size: 14px;
    }

    /* Config Cards - Helles Design wie der Rest */
    .finetuning-step .config-card {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    .finetuning-step .config-card h3 {
      color: #333;
      font-size: 16px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .finetuning-step .config-card h3 .icon {
      font-size: 20px;
    }

    /* Feintuning Linz-Filter */
    .ft-filter-area {
      margin-top: 12px;
    }
    .ft-filter-selected {
      background: #e8ffe8;
      border: 1px solid #90d090;
      border-radius: 10px;
      padding: 12px;
      margin-bottom: 16px;
    }
    .filter-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 40px;
    }
    .filter-item {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #4CAF50;
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 14px;
      font-weight: 500;
    }
    .filter-item .remove-filter {
      background: rgba(255,255,255,0.3);
      border: none;
      color: white;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .filter-item .remove-filter:hover {
      background: rgba(255,255,255,0.5);
    }
    .ft-filter-pool {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      padding: 12px;
    }
    .filter-pool-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: #f0f0f0;
      padding: 8px 14px;
      border-radius: 20px;
      font-size: 14px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: all 0.2s;
    }
    .filter-pool-item:hover {
      background: #e0e0e0;
      border-color: #4CAF50;
    }
    .filter-pool-item.selected {
      background: #4CAF50;
      color: white;
    }
    .no-filter-hint {
      color: #888;
      font-size: 13px;
      padding: 8px;
      text-align: center;
    }

    /* Feintuning Gruppierung */
    .ft-grouping-area {
      margin-top: 12px;
    }
    .ft-groups-container {
      margin-bottom: 16px;
    }
    .no-groups-hint {
      color: #888;
      font-size: 13px;
      padding: 12px;
      text-align: center;
      background: #f8f8f8;
      border-radius: 8px;
    }
    .ft-group-box {
      background: #f0f7ff;
      border: 1px solid #cce0ff;
      border-radius: 10px;
      margin-bottom: 10px;
      overflow: hidden;
    }
    .ft-group-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 12px;
      background: #e0edff;
      font-size: 13px;
      font-weight: 600;
      color: #336;
    }
    .ft-group-delete {
      background: none;
      border: none;
      color: #666;
      font-size: 16px;
      cursor: pointer;
      padding: 2px 8px;
      border-radius: 4px;
    }
    .ft-group-delete:hover {
      background: #ffdddd;
      color: #c00;
    }
    .ft-group-content {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 12px;
      min-height: 50px;
    }
    .ft-group-content.drag-over {
      background: #d0e8ff;
    }
    .ft-directions-pool {
      background: #fafafa;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      padding: 12px;
    }
    .ft-directions-pool.drag-over {
      background: #fff8e0;
      border-color: #e0c060;
    }
    .pool-header {
      font-size: 12px;
      color: #666;
      margin-bottom: 10px;
      font-weight: 500;
    }
    .pool-items {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .pool-empty {
      color: #999;
      font-size: 12px;
      padding: 8px;
    }
    .ft-direction-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      background: #fff;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 13px;
      transition: all 0.15s;
      user-select: none;
    }
    .ft-direction-chip.clickable {
      cursor: pointer;
    }
    .ft-direction-chip.clickable:hover,
    .ft-direction-chip.clickable:active {
      border-color: #0055a4;
      background: #e8f4ff;
    }
    .ft-direction-chip.selected {
      border-color: #0055a4;
      background: #0055a4;
      color: #fff;
    }
    .ft-direction-chip.selected .dir-dest {
      color: #fff;
    }
    .ft-direction-chip .line-badge {
      padding: 3px 8px;
      border-radius: 5px;
      font-weight: 700;
      font-size: 12px;
      min-width: 28px;
      text-align: center;
    }
    .ft-direction-chip .dir-dest {
      color: #555;
      font-size: 12px;
    }
    .ft-direction-chip .chip-remove {
      margin-left: 4px;
      color: #999;
      font-weight: bold;
      cursor: pointer;
    }
    .ft-direction-chip:hover .chip-remove {
      color: #c00;
    }

    /* Neue Gruppe erstellen Button */
    .ft-create-group-btn {
      display: block;
      width: 100%;
      padding: 14px;
      margin-top: 12px;
      background: #f0f5ff;
      border: 2px dashed #0055a4;
      border-radius: 10px;
      color: #0055a4;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s;
    }
    .ft-create-group-btn:hover,
    .ft-create-group-btn:active {
      background: #e0ebff;
    }

    /* Gruppe im Erstellungs-Modus */
    .ft-group-creating {
      border: 2px solid #0055a4;
      background: #f8fbff;
    }
    .ft-group-creating .ft-group-header {
      background: #0055a4;
      color: #fff;
    }
    .ft-group-creating .hint {
      color: #888;
      font-size: 12px;
      font-style: italic;
    }
    .ft-group-actions {
      display: flex;
      gap: 10px;
      padding: 12px;
      border-top: 1px solid #e0e0e0;
    }
    .ft-group-actions .btn-cancel {
      flex: 1;
      padding: 10px;
      background: #f0f0f0;
      border: none;
      border-radius: 8px;
      color: #666;
      font-size: 14px;
      cursor: pointer;
    }
    .ft-group-actions .btn-confirm {
      flex: 1;
      padding: 10px;
      background: #0055a4;
      border: none;
      border-radius: 8px;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .ft-group-actions .btn-confirm:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    /* Gruppe Box */
    .ft-group-box {
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      margin-bottom: 12px;
      overflow: hidden;
    }
    .ft-group-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 14px;
      background: #f5f5f5;
      border-bottom: 1px solid #e0e0e0;
      font-weight: 600;
      font-size: 13px;
    }
    .ft-group-delete {
      background: none;
      border: none;
      color: #c00;
      font-size: 12px;
      cursor: pointer;
      padding: 4px 8px;
    }
    .ft-group-content {
      padding: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      min-height: 40px;
    }

    /* Form Rows */
    .finetuning-step .form-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 0;
      border-bottom: 1px solid #f0f0f0;
    }
    .finetuning-step .form-row:last-child {
      border-bottom: none;
    }
    .finetuning-step .form-label {
      color: #333;
      font-size: 14px;
      font-weight: 500;
    }
    .finetuning-step .form-hint {
      font-size: 12px;
      color: #888;
      margin-top: 4px;
      font-weight: 400;
    }

    /* Selects - Helles Design */
    .finetuning-step select {
      background: #fff;
      border: 2px solid #e0e0e0;
      color: #333;
      padding: 10px 14px;
      border-radius: 10px;
      font-size: 14px;
      min-width: 150px;
      cursor: pointer;
      -webkit-appearance: none;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }
    .finetuning-step select:focus {
      outline: none;
      border-color: #0055a4;
    }

    /* Inputs - Helles Design */
    .finetuning-step input[type="number"],
    .finetuning-step input[type="text"] {
      background: #fff;
      border: 2px solid #e0e0e0;
      color: #333;
      padding: 10px 14px;
      border-radius: 10px;
      font-size: 14px;
      width: 70px;
      text-align: center;
    }
    .finetuning-step input:focus {
      outline: none;
      border-color: #0055a4;
    }

    /* Toggle Switches - Helles Design */
    .finetuning-step .toggle-switch {
      position: relative;
      width: 52px;
      height: 28px;
      background: #e0e0e0;
      border-radius: 14px;
      cursor: pointer;
      transition: background 0.3s;
      flex-shrink: 0;
    }
    .finetuning-step .toggle-switch.active {
      background: #0055a4;
    }
    .finetuning-step .toggle-switch::after {
      content: '';
      position: absolute;
      width: 22px;
      height: 22px;
      background: #fff;
      border-radius: 50%;
      top: 3px;
      left: 3px;
      transition: transform 0.3s;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    .finetuning-step .toggle-switch.active::after {
      transform: translateX(24px);
    }

    /* Station Gehweg List */
    .finetuning-step .gehweg-list {
      margin-top: 12px;
    }
    .finetuning-step .gehweg-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 14px;
      background: #f8f8f8;
      border-radius: 10px;
      margin-bottom: 8px;
    }
    .finetuning-step .gehweg-item .station-name {
      flex: 1;
      font-size: 14px;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .finetuning-step .gehweg-item input {
      width: 60px;
    }
    .finetuning-step .gehweg-item .unit {
      color: #888;
      font-size: 13px;
    }

    /* Display Preview in Finetuning */
    .finetuning-step .preview-container {
      display: flex;
      justify-content: center;
      margin-bottom: 24px;
    }
    .finetuning-step .preview-display {
      width: 220px;
      height: 130px;
      background: #000;
      border-radius: 12px;
      border: 4px solid #333;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    /* Bottom Actions - Helles Design */
    .finetuning-step .bottom-actions {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #fff;
      border-top: 1px solid #e0e0e0;
      padding: 16px 20px;
      display: flex;
      gap: 12px;
      box-shadow: 0 -2px 10px rgba(0,0,0,0.05);
      z-index: 1001;
    }
    .finetuning-step .btn-save-finetuning,
    .finetuning-step .btn-back-finetuning {
      flex: 1;
      padding: 14px;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      transition: all 0.2s;
    }
    .finetuning-step .btn-save-finetuning {
      background: #0055a4;
      color: #fff;
    }
    .finetuning-step .btn-save-finetuning:hover {
      background: #004080;
      transform: translateY(-1px);
    }
    .finetuning-step .btn-back-finetuning {
      background: #f0f0f0;
      color: #333;
    }
    .finetuning-step .btn-back-finetuning:hover {
      background: #e0e0e0;
    }

    /* Wien-specific badge */
    .finetuning-step .wien-only-badge {
      background: #E20613;
      color: #fff;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: 8px;
    }

    /* Hidden form rows */
    .finetuning-step .form-row.feature-hidden {
      display: none;
    }

    /* Zeilen-Reihenfolge Drag & Drop */
    .ft-row-order-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .ft-row-order-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      background: #f8f8f8;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      cursor: grab;
      transition: all 0.2s;
      user-select: none;
    }
    .ft-row-order-item:hover {
      border-color: #0055a4;
      background: #f0f5fa;
    }
    .ft-row-order-item.dragging {
      opacity: 0.5;
      border-color: #0055a4;
      background: #e8f0f8;
    }
    .ft-row-order-item .drag-handle {
      color: #999;
      font-size: 18px;
      cursor: grab;
    }
    .ft-row-order-item .row-number {
      background: #0055a4;
      color: #fff;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      font-size: 14px;
      flex-shrink: 0;
    }
    .ft-row-order-item .line-badge {
      padding: 4px 10px;
      border-radius: 6px;
      font-weight: 700;
      font-size: 14px;
      background: #333;
      color: #fff;
    }
    .ft-row-order-item .direction-text {
      flex: 1;
      font-size: 14px;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* Gruppen-Styling in der Reihenfolge */
    .ft-row-order-item.ft-row-order-group {
      background: linear-gradient(135deg, #f0f5fa 0%, #e8f0f8 100%);
      border-color: #0055a4;
    }
    .ft-row-order-item .group-badges {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }
    .ft-row-order-item .group-badges .line-badge {
      padding: 3px 8px;
      font-size: 12px;
    }
    .ft-row-order-empty {
      padding: 20px;
      text-align: center;
      color: #888;
      font-size: 14px;
      background: #f8f8f8;
      border-radius: 10px;
      border: 2px dashed #ddd;
    }

    /* Night Mode Times */
    .finetuning-step .night-times {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .finetuning-step .night-times span {
      color: #666;
    }

    /* Toggle Row (Zeilen, Helligkeit) */
    .finetuning-step .toggle-row {
      display: flex;
      background: #f0f0f0;
      border-radius: 10px;
      padding: 4px;
      gap: 4px;
    }
    .finetuning-step .toggle-btn {
      padding: 10px 18px;
      border: none;
      background: transparent;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      color: #666;
      cursor: pointer;
      transition: all 0.2s;
    }
    .finetuning-step .toggle-btn:hover {
      background: #e0e0e0;
    }
    .finetuning-step .toggle-btn.active {
      background: #0055a4;
      color: #fff;
    }
  </style>
</head>
<body>

<div class="container">
  <div class="header">
    <h1>Städte & Netze</h1>
    <p>Wähle Stationen aus verschiedenen Verkehrsnetzen</p>
  </div>
  
  <!-- Breadcrumb -->
  <div class="breadcrumb" id="breadcrumb">
    <span class="breadcrumb-item active">Region wählen</span>
  </div>
  
  <!-- Step 1: Region -->
  <div class="card" id="stepRegion">
    <h2>Region wählen</h2>
    <div class="selection-grid">
      <button class="selection-btn" onclick="selectRegion('AT')">
        <div class="region-badge at"></div>
        <div class="name">Österreich</div>
        <div class="desc">Wien, Linz, Badner Bahn</div>
      </button>
      <button class="selection-btn" onclick="selectRegion('DE')">
        <div class="region-badge de"></div>
        <div class="name">Deutschland</div>
        <div class="desc">DB, Berlin, Bodensee</div>
      </button>
      <button class="selection-btn disabled" onclick="selectRegion('CH')">
        <div class="region-badge ch">CH</div>
        <div class="name">Schweiz</div>
        <div class="desc">Bald verfügbar</div>
      </button>
      <button class="selection-btn disabled" onclick="selectRegion('DK')">
        <div class="region-badge dk">DK</div>
        <div class="name">Dänemark</div>
        <div class="desc">Bald verfügbar</div>
      </button>
    </div>
  </div>
  
  <!-- Step 2: Network -->
  <div class="card hidden" id="stepNetwork">
    <button class="back-btn" onclick="goBack('region')">Zurück</button>
    <h2>Netzwerk wählen</h2>
    <div class="selection-grid" id="networkGrid"></div>
  </div>
  
  <!-- Step 3: Search Station (für normale Netze) -->
  <div class="card hidden" id="stepSearch">
    <button class="back-btn" onclick="goBack('network')">Zurück</button>
    <h2>Station suchen</h2>
    <div class="search-container">
      <span class="search-icon"></span>
      <input type="text" class="search-input" id="searchInput" placeholder="Stationsname eingeben..." autocomplete="off">
      <div class="search-spinner" id="searchSpinner"></div>
    </div>
    <div class="search-results" id="searchResults"></div>
  </div>
  
  <!-- Step 3b: Journey Search (für DB) -->
  <div class="card hidden" id="stepJourneySearch">
    <button class="back-btn" onclick="goBack('network')">Zurück</button>
    <h2>Verbindung wählen</h2>
    
    <div class="journey-field">
      <label>Von:</label>
      <div class="search-container">
        <span class="search-icon"></span>
        <input type="text" class="search-input" id="journeyFromInput" placeholder="Abfahrtsstation..." autocomplete="off">
        <div class="search-spinner" id="journeyFromSpinner"></div>
      </div>
      <div class="search-results" id="journeyFromResults"></div>
      <div class="journey-selected hidden" id="journeyFromSelected"></div>
    </div>
    
    <div class="journey-arrow"></div>
    
    <div class="journey-field">
      <label>Nach:</label>
      <div class="search-container">
        <span class="search-icon"></span>
        <input type="text" class="search-input" id="journeyToInput" placeholder="Zielstation..." autocomplete="off">
        <div class="search-spinner" id="journeyToSpinner"></div>
      </div>
      <div class="search-results" id="journeyToResults"></div>
      <div class="journey-selected hidden" id="journeyToSelected"></div>
    </div>
    
    <!-- Zugauswahl erscheint automatisch -->
    <div class="journey-products hidden" id="journeyProductsSection">
      <h3 style="color:#0055a4;margin:20px 0 12px;font-size:16px;">Züge auswählen</h3>
      
      <div class="product-category">
        <div class="category-header" onclick="toggleCategory('domestic')">
          <span>Deutsche Züge</span>
          <span class="category-toggle" id="domesticToggle">▼</span>
        </div>
        <div class="category-content" id="domesticProducts"></div>
      </div>
      
      <div class="product-category">
        <div class="category-header" onclick="toggleCategory('international')">
          <span>International</span>
          <span class="category-toggle" id="internationalToggle">▼</span>
        </div>
        <div class="category-content" id="internationalProducts"></div>
      </div>
      
      <button class="btn btn-primary" id="addJourneyBtn" onclick="addJourneyStation()" disabled style="margin-top:16px;width:100%">
        Verbindung hinzufügen
      </button>
    </div>
  </div>
  
  
  <!-- Step 3c: Wien Line Selection (wie localmainpage) -->
  <div class="card hidden" id="stepWienLine">
    <button class="back-btn" onclick="goBack('network')">Zurück</button>
    <h2><span class="network-badge wl">WL</span> Linie wählen</h2>
    <div class="search-container">
      <span class="search-icon"></span>
      <input type="text" class="search-input" id="wienLineInput" placeholder="Linie suchen (z.B. U6, 13A)..." autocomplete="off">
    </div>
    <div class="search-results" id="wienLineResults"></div>
  </div>

  <!-- Step 3d: Wien Station Selection -->
  <div class="card hidden" id="stepWienStation">
    <button class="back-btn" onclick="goBack('wienLine')">Zurück</button>
    <h2 id="wienSelectedLineName" style="color:#E20613;">Station wählen</h2>
    <div class="search-container">
      <span class="search-icon"></span>
      <input type="text" class="search-input" id="wienStationInput" placeholder="Station suchen..." autocomplete="off">
    </div>
    <div class="search-results" id="wienStationResults"></div>
  </div>

  <!-- Step 3e: Wien Direction Selection -->
  <div class="card hidden" id="stepWienDirection">
    <button class="back-btn" onclick="goBack('wienStation')">Zurück</button>
    <h2 id="wienDirectionTitle" style="color:#E20613;">Richtung wählen</h2>
    <p style="color:#666;font-size:13px;margin-bottom:16px;" id="wienDirectionInfo"></p>

    <div id="wienDirectionList" class="lines-container"></div>

    <!-- Andere Linien an dieser Station -->
    <div id="wienOtherLinesSection" style="display:none;margin-top:20px;">
      <h3 style="color:#0055a4;font-size:14px;margin-bottom:12px;">📍 Andere Linien an dieser Station</h3>
      <div id="wienOtherLinesList"></div>
    </div>

    <button class="btn btn-primary" id="wienAddStationBtn" onclick="addWienStation()" disabled style="margin-top:16px;">
      Station hinzufügen
    </button>
  </div>

  <!-- Step 4: Select Lines (für andere Netze) -->
  <div class="card hidden" id="stepLines">
    <button class="back-btn" onclick="goBack('search')">Zurück</button>
    <h2 id="selectedStationName" style="color:#0055a4;">Linien auswählen</h2>
    <p style="color:#666;font-size:13px;margin-bottom:16px;" id="selectedStationInfo"></p>

    <div class="lines-loading" id="linesLoading">
      <div class="spinner"></div>
      <div>Lade Abfahrten...</div>
    </div>

    <div class="lines-container hidden" id="linesContainer">
      <div class="lines-header">
        <h3>Welche Linien anzeigen?</h3>
        <button class="select-all-btn" id="selectAllBtn" onclick="toggleSelectAll()">Alle auswählen</button>
      </div>
      <div id="linesList"></div>
    </div>

    <button class="btn btn-primary" id="addStationBtn" onclick="showGroupingStep()" disabled>
      Weiter
    </button>
  </div>

  <!-- Step 5 entfernt - Gruppierung jetzt nur im Feintuning -->

  <!-- Added Stations -->
  <div class="card" id="stationsCard">
    <h2>Deine Stationen (<span id="stationCount">0</span>)</h2>
    <div id="stationsContainer">
      <div class="empty-state" id="emptyState">
        <p>Noch keine Stationen hinzugefügt</p>
      </div>
    </div>
    <button class="btn btn-primary hidden" id="openFinetuningBtn" onclick="handleStationsNextStep()" style="margin-top: 12px; width: 100%;">
      Weiter
    </button>
  </div>
  
  <!-- Step: Display Config -->
  <div class="card hidden" id="stepDisplayConfig">
    <button class="back-btn" onclick="backFromDisplayConfig()">Zurück</button>
    <h2>Display-Einstellungen</h2>
    
    <div class="config-suggestion">
      <div class="suggestion-header">
        <span class="suggestion-label">Empfohlen für deine Auswahl:</span>
      </div>
      
      <div class="suggestion-preview" id="suggestionPreview">
        <div class="preview-image" id="previewImage">
          <!-- Animated preview -->
        </div>
        <div class="preview-info">
          <div class="preview-title" id="previewTitle">Wiener Linien Ansicht</div>
          <div class="preview-desc" id="previewDesc">2 Zeilen, optimal für U-Bahn und Tram</div>
        </div>
      </div>
      
      <div class="suggestion-details">
        <div class="detail-row">
          <span class="detail-label">Display-Typ:</span>
          <span class="detail-value" id="suggestedColorName">Wiener Linien</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Zeilen:</span>
          <span class="detail-value" id="suggestedRows">2</span>
        </div>
      </div>
    </div>
    
    <div class="config-actions">
      <button class="btn btn-primary btn-large btn-success" onclick="sendWithSuggestion()">
        ✓ Ja, passt – fertig
      </button>
      <button class="btn btn-secondary btn-large" onclick="goToFinetuning()">
        Nein / Feintuning
      </button>
    </div>

    <p class="config-hint">
      "Ja, passt" speichert die Einstellungen direkt auf deinem Straba.<br>
      "Feintuning" öffnet erweiterte Optionen für individuelle Anpassungen.
    </p>

    <!-- Quick Preview der gewählten Optionen -->
    <div class="quick-settings-preview" id="quickSettingsPreview">
      <h4>Zusammenfassung</h4>
      <div class="settings-list" id="settingsList">
        <!-- Wird dynamisch gefüllt -->
      </div>
    </div>

    <!-- Kompakter Feintuning-Bereich (optional, versteckt) -->
    <div class="finetuning-section hidden" id="finetuningSection">
      <h3>Quick-Anpassung</h3>

      <div class="finetuning-row">
        <label>Display-Typ:</label>
        <select id="colorSelect" onchange="updateQuickPreview()">
          <option value="1">Wiener Linien</option>
          <option value="2">Linz AG</option>
          <option value="3">VBB Berlin</option>
          <option value="4">WLB Badner Bahn</option>
          <option value="5">DB S-Bahn</option>
          <option value="6">DB Fernverkehr</option>
          <option value="7">BODO Bodensee</option>
        </select>
      </div>

      <div class="finetuning-row">
        <label>Anzahl Zeilen:</label>
        <select id="rowsSelect" onchange="updateQuickPreview()">
          <option value="1">1 Zeile</option>
          <option value="2">2 Zeilen</option>
          <option value="3">3 Zeilen</option>
        </select>
      </div>

      <!-- Wien-spezifische Optionen (werden dynamisch ein-/ausgeblendet) -->
      <div class="wien-options" id="wienOptions" style="display:none;">
        <div class="finetuning-row">
          <label>Hochflurer markieren:</label>
          <select id="chopperSelect">
            <option value="1">An</option>
            <option value="0">Aus</option>
          </select>
        </div>
        <div class="finetuning-row">
          <label>Klimaanlage (U-Bahn):</label>
          <select id="silberpfeilSelect">
            <option value="1">An</option>
            <option value="0">Aus</option>
          </select>
        </div>
      </div>

      <!-- Gehweg für ALLE Städte -->
      <div class="gehweg-quick" id="gehwegQuick">
        <h4>Gehweg zur Haltestelle</h4>
        <p class="gehweg-hint">Abfahrten unter der Minutenzahl werden ausgeblendet</p>
        <div id="gehwegQuickList">
          <!-- Wird dynamisch gefüllt -->
        </div>
      </div>

      <button class="btn btn-primary" onclick="applyQuickSettings()">
        Mit Anpassungen speichern
      </button>
    </div>
  </div>
</div><!-- Ende .container -->

<!-- Step: Integriertes Feintuning - Full-Screen Overlay (außerhalb Container) -->
<div class="finetuning-step hidden" id="stepFinetuning">
  <div class="ft-container">
    <div class="header">
      <h1>Feintuning</h1>
      <p>Passe dein Display individuell an</p>
    </div>

    <!-- Display Preview -->
    <div class="preview-container">
      <div class="preview-display" id="finetuningPreview">
        <!-- Wird dynamisch gefüllt -->
      </div>
    </div>

    <!-- Display Typ -->
    <div class="config-card">
      <h3>Anzeige-Stil</h3>
      <div class="form-row">
        <div>
          <div class="form-label">Display-Typ</div>
          <div class="form-hint">Farbschema des Displays</div>
        </div>
        <select id="ftColorSelect" onchange="updateFinetuningPreview()">
          <option value="1">Wiener Linien</option>
          <option value="2">Linz AG</option>
          <option value="3">VBB Berlin</option>
          <option value="4">WLB Badner Bahn</option>
          <option value="5">DB S-Bahn</option>
          <option value="6">DB Fernverkehr</option>
          <option value="7">BODO Bodensee</option>
          <option value="8">Salzburg AG</option>
        </select>
      </div>
      <div class="form-row">
        <div>
          <div class="form-label">Zeilen</div>
          <div class="form-hint">Anzahl der Abfahrten</div>
        </div>
        <div class="toggle-row" id="ftRowsToggle">
          <button class="toggle-btn" data-value="1" onclick="setFtRows(1)">1</button>
          <button class="toggle-btn active" data-value="2" onclick="setFtRows(2)">2</button>
          <button class="toggle-btn" data-value="3" onclick="setFtRows(3)">3</button>
        </div>
      </div>
      <div class="form-row">
        <div>
          <div class="form-label">Helligkeit</div>
        </div>
        <div class="toggle-row" id="ftBrightnessToggle">
          <button class="toggle-btn" data-value="1" onclick="setFtBrightness(1)">Dunkel</button>
          <button class="toggle-btn" data-value="2" onclick="setFtBrightness(2)">Mittel</button>
          <button class="toggle-btn active" data-value="3" onclick="setFtBrightness(3)">Hell</button>
        </div>
      </div>
    </div>

    <!-- Wien-spezifische Optionen -->
    <div class="config-card" id="ftWienOptions" style="display:none;">
      <h3>Wien-Optionen <span class="wien-only-badge">WL</span></h3>
      <div class="form-row" id="ftRowChopper">
        <div>
          <div class="form-label">Hochflurer markieren</div>
          <div class="form-hint">Hebt altere Garnituren hervor</div>
        </div>
        <div class="toggle-switch active" id="ftChopperToggle" onclick="toggleFtSwitch('ftChopperToggle')"></div>
      </div>
      <div class="form-row" id="ftRowSilberpfeil">
        <div>
          <div class="form-label">Klimaanlage anzeigen</div>
          <div class="form-hint">U-Bahn Silberpfeil-Warnung</div>
        </div>
        <div class="toggle-switch active" id="ftSilberpfeilToggle" onclick="toggleFtSwitch('ftSilberpfeilToggle')"></div>
      </div>
    </div>

    <!-- Richtungs-Gruppierung & Sortierung -->
    <div class="config-card" id="ftGroupingCard">
      <h3>Richtungen gruppieren</h3>
      <p class="form-hint" style="margin-bottom:12px;">
        Gruppiere Linien die die gleiche Strecke fahren (z.B. Linie 1 und 62).
        Nicht gruppierte Linien werden einzeln angezeigt.
      </p>

      <div class="ft-grouping-area">
        <div class="ft-groups-container" id="ftGroupsContainer">
          <!-- Gruppen werden hier gerendert -->
        </div>

        <div class="ft-directions-pool" id="ftDirectionsPool">
          <div class="pool-header">Verfuegbare Richtungen:</div>
          <div class="pool-items" id="ftPoolItems">
            <!-- Richtungen werden hier gerendert -->
          </div>
        </div>
      </div>

      <!-- Sortierung Toggle -->
      <div style="margin-top:20px; padding-top:16px; border-top:1px solid #e0e0e0;">
        <div class="form-row">
          <div>
            <div class="form-label">Sortierung</div>
            <div class="form-hint">Dynamisch nach Zeit oder feste Reihenfolge</div>
          </div>
          <div class="toggle-row" id="ftSortModeToggle">
            <button class="toggle-btn active" data-value="1" onclick="setFtSortMode(1)">Zeit</button>
            <button class="toggle-btn" data-value="2" onclick="setFtSortMode(2)">Statisch</button>
          </div>
        </div>
        <!-- Info-Box für Sortierungsmodi -->
        <div id="ftSortModeInfo" style="margin-top:12px; padding:12px; background:#f5f5f5; border-radius:8px; font-size:13px; color:#555;">
          <div id="ftSortModeInfoTime" style="display:block;">
            <strong>Zeit:</strong> Die nächsten Abfahrten werden immer oben angezeigt - egal welche Linie. Ideal wenn du einfach den nächsten Zug/Bus nehmen willst.
          </div>
          <div id="ftSortModeInfoStatic" style="display:none;">
            <strong>Statisch:</strong> Jede Linie hat eine feste Zeile auf dem Display. Du kannst unten die Reihenfolge festlegen. Ideal wenn du immer dieselbe Linie im Blick haben willst.
          </div>
        </div>
      </div>

      <!-- Zeilen-Reihenfolge (nur bei Statisch sichtbar) -->
      <div id="ftRowOrderSection" style="display:none; margin-top:16px; padding-top:16px; border-top:1px solid #e0e0e0;">
        <div class="form-label" style="margin-bottom:12px;">Zeilen-Reihenfolge festlegen</div>
        <div class="form-hint" style="margin-bottom:12px;">Ziehe die Gruppen/Linien in die gewünschte Reihenfolge (Zeile 1 = oben)</div>
        <div class="ft-row-order-list" id="ftRowOrderList">
          <!-- Wird dynamisch gefüllt mit drag & drop Items (Gruppen + einzelne Linien) -->
        </div>
      </div>
    </div>

    <!-- Nachtmodus -->
    <div class="config-card">
      <h3>Nachtmodus</h3>
      <div class="form-row">
        <div>
          <div class="form-label">Nachtmodus aktivieren</div>
          <div class="form-hint">Display nachts dimmen</div>
        </div>
        <div class="toggle-switch" id="ftNightModeToggle" onclick="toggleFtSwitch('ftNightModeToggle'); updateNightTimeVisibility()"></div>
      </div>
      <div class="form-row" id="ftNightTimesRow" style="display:none;">
        <div>
          <div class="form-label">Uhrzeit</div>
        </div>
        <div class="night-times">
          <input type="number" id="ftNightStart" min="0" max="23" value="22"> <span>bis</span>
          <input type="number" id="ftNightEnd" min="0" max="23" value="6"> <span>Uhr</span>
        </div>
      </div>
    </div>

    <!-- Gehweg -->
    <div class="config-card">
      <h3>Gehweg zur Haltestelle</h3>
      <p class="form-hint" style="margin-bottom:12px;">Abfahrten unter dieser Minutenzahl werden ausgeblendet</p>
      <div class="gehweg-list" id="ftGehwegList">
        <!-- Wird dynamisch gefüllt -->
      </div>
    </div>

    <!-- Fun Messages -->
    <div class="config-card">
      <h3>Extras</h3>
      <div class="form-row">
        <div>
          <div class="form-label">Spaß-Nachrichten</div>
          <div class="form-hint">Zeigt witzige Meldungen bei langen Wartezeiten</div>
        </div>
        <div class="toggle-switch" id="ftFunMessagesToggle" onclick="toggleFtSwitch('ftFunMessagesToggle')"></div>
      </div>
    </div>

    <!-- Spacer für Bottom Actions -->
    <div style="height: 100px;"></div>
  </div><!-- Ende ft-container -->

  <!-- Bottom Actions -->
  <div class="bottom-actions">
    <div style="max-width:500px;margin:0 auto;display:flex;gap:12px;width:100%;">
      <button class="btn btn-back-finetuning" onclick="backFromFinetuning()">Zurück</button>
      <button class="btn btn-save-finetuning" onclick="saveFromFinetuning()">Speichern</button>
    </div>
  </div>
</div><!-- Ende finetuning-step -->

<!-- Bottom Bar -->
<div class="bottom-bar">
  <div class="container">
    <button class="btn btn-save" id="saveBtn" onclick="goToDisplayConfig()" disabled>
      Weiter
    </button>
  </div>
</div>

<script>
// ==================== EARLY MESSAGE HANDLER ====================
// Fängt Nachrichten ab, die vor dem Laden des restlichen Scripts ankommen
let _pendingConfigMessages = [];
let _configHandlerReady = false;

window.addEventListener('message', function(event) {
  if (event.data?.type === 'loadFullConfig' || event.data?.type === 'loadExistingConfig') {
    if (_configHandlerReady) {
      // Handler ist bereit, nichts zu tun (wird vom späteren Handler verarbeitet)
    } else {
      // Puffere Nachrichten für später
      _pendingConfigMessages.push(event.data);
    }
  }
});

// ==================== CONFIG ====================
const REGIONS = {
  AT: {
    name: 'Österreich',
    networks: ['WL', 'WLB', 'LINZ', 'SALZBURG']
  },
  DE: {
    name: 'Deutschland',
    networks: ['DB', 'BERLIN', 'BODO']
  },
  CH: {
    name: 'Schweiz',
    networks: []
  },
  DK: {
    name: 'Dänemark',
    networks: []
  }
};

// ==================== CITY CAPABILITIES ====================
// Definiert welche Features pro Netzwerk verfügbar sind
const CITY_CAPABILITIES = {
  WL: {
    textColorChangeable: true,    // Textfarbe änderbar (Amber/Weiß/Orange)
    showHighFloor: true,          // Hochflurer-Warnung
    showAirCondition: true,       // Klimaanlage-Anzeige (U-Bahn Silberpfeil)
    gehwegFilter: true,           // Gehweg-Filter (ALLE Städte)
    nightMode: true,              // Nachtmodus (ALLE Städte)
    defaultColour: 1,             // Wiener Linien Gelb
    defaultBrightness: 3          // Hell
  },
  WLB: {
    textColorChangeable: false,
    showHighFloor: false,
    showAirCondition: false,
    gehwegFilter: true,
    nightMode: true,
    defaultColour: 4,             // WLB Blau
    defaultBrightness: 3
  },
  LINZ: {
    textColorChangeable: true,
    showHighFloor: false,
    showAirCondition: false,
    gehwegFilter: true,
    nightMode: true,
    defaultColour: 2,             // Linz AG
    defaultBrightness: 3
  },
  DB: {
    textColorChangeable: false,
    showHighFloor: false,
    showAirCondition: false,
    gehwegFilter: true,
    nightMode: true,
    defaultColour: 6,             // DB Fernverkehr
    defaultBrightness: 3
  },
  BERLIN: {
    textColorChangeable: false,
    showHighFloor: false,
    showAirCondition: false,
    gehwegFilter: true,
    nightMode: true,
    defaultColour: 3,             // VBB Berlin
    defaultBrightness: 3
  },
  BODO: {
    textColorChangeable: false,
    showHighFloor: false,
    showAirCondition: false,
    gehwegFilter: true,
    nightMode: true,
    defaultColour: 7,             // BODO
    defaultBrightness: 3
  },
  SALZBURG: {
    textColorChangeable: false,
    showHighFloor: false,
    showAirCondition: false,
    gehwegFilter: true,
    nightMode: true,
    defaultColour: 8,             // Salzburg AG
    defaultBrightness: 3
  }
};

const NETWORKS = {
  WL: {
    name: 'Wiener Linien',
    shortName: 'WL',
    region: 'AT',
    desc: 'U-Bahn, Straßenbahn, Bus',
    searchType: 'wien_json',
    placeholder: 'z.B. Karlsplatz, Stephansplatz...',
    isJourneyBased: false
  },
  LINZ: {
    name: 'Linz AG Linien',
    shortName: 'LINZ',
    region: 'AT', 
    desc: 'Straßenbahn, Bus',
    searchType: 'server_proxy',
    placeholder: 'z.B. Hauptbahnhof, Taubenmarkt...',
    isJourneyBased: false
  },
  WLB: {
    name: 'Wiener Lokalbahnen',
    shortName: 'WLB',
    region: 'AT',
    desc: 'Badner Bahn (Wien - Baden)',
    searchType: 'static_list',
    placeholder: 'Haltestelle auswählen...',
    isJourneyBased: false,
    stations: [
      // Wien
      { id: '490097507', name: 'Wien Oper/Karlsplatz', info: 'Kärntner Ring' },
      { id: '490065711', name: 'Wien Karlsplatz', info: '' },
      { id: '490109401', name: 'Wien Resselgasse', info: '' },
      { id: '490099601', name: 'Wien Paulanergasse', info: '' },
      { id: '490085902', name: 'Wien Mayerhofgasse', info: '' },
      { id: '490060401', name: 'Wien Johann-Strauß-Gasse', info: '' },
      { id: '490075502', name: 'Wien Laurenzgasse', info: '' },
      { id: '490068901', name: 'Wien Kliebergasse', info: '' },
      { id: '490084912', name: 'Wien Matzleinsdorfer Platz', info: '' },
      { id: '490026705', name: 'Wien Eichenstraße', info: 'Gürtel' },
      { id: '490084401', name: 'Wien Marx-Meidlinger-Straße', info: '' },
      { id: '490036801', name: 'Wien Längenfeldgasse', info: 'Flurschützstraße' },
      { id: '490010301', name: 'Wien Aßmayergasse', info: '' },
      { id: '490086503', name: 'Wien Dörfelstraße', info: '' },
      { id: '490101505', name: 'Wien Meidling', info: 'Bahnhof' },
      { id: '490116002', name: 'Wien Schedifkaplatz', info: 'Meidling' },
      { id: '490121402', name: 'Wien Schöpfwerk', info: '' },
      { id: '490044401', name: 'Wien Gutheil-Schoder-Gasse', info: '' },
      { id: '490058502', name: 'Wien Inzersdorf Lokalbahn', info: '' },
      { id: '490091801', name: 'Wien Neu Erlaa', info: '' },
      { id: '490075902', name: 'Wien Schönbrunner Allee', info: '' },
      // Niederösterreich
      { id: '430513303', name: 'Vösendorf-Siebenhirten', info: '' },
      { id: '430513202', name: 'Vösendorf SCS', info: 'Shopping City Süd' },
      { id: '430416402', name: 'Maria Enzersdorf-Südstadt', info: 'Bahnhof' },
      { id: '430520106', name: 'Wiener Neudorf Bahnhof', info: '' },
      { id: '430520001', name: 'Wiener Neudorf Griesfeld', info: '' },
      { id: '430433104', name: 'Neu-Guntramsdorf', info: 'Lokalbahn' },
      { id: '430361504', name: 'Guntramsdorf Lokalbahn', info: '' },
      { id: '430430202', name: 'Eigenheimsiedlung', info: '' },
      { id: '430430404', name: 'Möllersdorf Lokalbahn', info: '' },
      { id: '430500104', name: 'Traiskirchen Lokalbahn', info: '' },
      { id: '430502202', name: 'Tribuswinkel-Josefsthal', info: 'Bahnhof' },
      { id: '430453602', name: 'Pfaffstätten Rennplatz', info: '' },
      { id: '430580902', name: 'Baden Melkergründe', info: '' },
      { id: '430605501', name: 'Baden Landesklinikum', info: '' },
      { id: '430314203', name: 'Baden Leesdorf', info: '' },
      { id: '430313402', name: 'Baden Viadukt', info: '' },
      { id: '430312101', name: 'Baden Josefsplatz', info: 'Endstation' }
    ]
  },
  DB: {
    name: 'Deutsche Bahn',
    shortName: 'DB',
    region: 'DE',
    desc: 'ICE, IC, RJ, RE, S-Bahn',
    searchType: 'server_proxy',
    placeholder: 'z.B. München Hbf, Berlin Hbf...',
    isJourneyBased: true,
    productCategories: {
      domestic: {
        label: 'Deutsche Züge',
        products: [
          { id: 'ICE', name: 'ICE', desc: 'Intercity-Express' },
          { id: 'IC', name: 'IC', desc: 'Intercity' },
          { id: 'EC', name: 'EC', desc: 'Eurocity' },
          { id: 'RE', name: 'RE', desc: 'Regional-Express' },
          { id: 'RB', name: 'RB', desc: 'Regionalbahn' },
          { id: 'S', name: 'S', desc: 'S-Bahn' }
        ]
      },
      international: {
        label: 'International',
        products: [
          { id: 'RJX', name: 'RJX', desc: 'Railjet Xpress (ÖBB)' },
          { id: 'RJ', name: 'RJ', desc: 'Railjet (ÖBB)' },
          { id: 'NJ', name: 'NJ', desc: 'Nightjet (ÖBB)' },
          { id: 'TGV', name: 'TGV', desc: 'TGV (SNCF)' },
          { id: 'THA', name: 'THA', desc: 'Thalys' },
          { id: 'FLX', name: 'FLX', desc: 'Flixtrain' }
        ]
      }
    }
  },
  BERLIN: {
    name: 'VBB Berlin',
    shortName: 'VBB',
    region: 'DE',
    desc: 'U-Bahn, S-Bahn, Tram, Bus',
    searchType: 'server_proxy',
    placeholder: 'z.B. Alexanderplatz...',
    isJourneyBased: false
  },
  BODO: {
    name: 'BODO',
    shortName: 'BODO',
    region: 'DE',
    desc: 'Bodensee-Oberschwaben',
    searchType: 'server_proxy',
    placeholder: 'z.B. Ravensburg, Bahnhof...',
    isJourneyBased: false
  },
  SALZBURG: {
    name: 'Salzburg Verkehr (SVV)',
    shortName: 'SBG',
    region: 'AT',
    desc: 'Obus, Lokalbahn, Pinzgauer Bahn',
    searchType: 'static_list',
    placeholder: 'Haltestelle suchen...',
    isJourneyBased: false,
    stations: [
      // Stadt Salzburg
      { id: 'salzburg-hbf', name: 'Salzburg Hauptbahnhof', info: 'Obus, Lokalbahn, S-Bahn' },
      { id: 'mirabellplatz', name: 'Mirabellplatz', info: 'Obus 1,2,5,6' },
      { id: 'makartplatz', name: 'Makartplatz', info: 'Obus 3,5,6' },
      { id: 'rathaus', name: 'Rathaus', info: 'Obus 3,5,6,8' },
      { id: 'hanuschplatz', name: 'Hanuschplatz', info: 'Obus 1,2,4,7' },
      { id: 'mozartsteg', name: 'Mozartsteg', info: 'Obus 3,7,8' },
      { id: 'theatergasse', name: 'Theatergasse', info: 'Obus' },
      { id: 'salzburg-sued', name: 'Salzburg Süd P+R', info: 'Obus 3,8' },
      { id: 'europark', name: 'Europark', info: 'Obus 1,10' },
      { id: 'flughafen', name: 'Salzburg Flughafen', info: 'Obus 2,10' },
      { id: 'paris-lodron-strasse', name: 'Universität', info: 'Obus 4,7' },
      { id: 'gnigl', name: 'Gnigl', info: 'Obus 5,6' },
      { id: 'maxglan-west', name: 'Maxglan West', info: 'Obus 1' },
      { id: 'itzling', name: 'Itzling', info: 'Obus, S-Bahn' },
      { id: 'aiglhof', name: 'Aiglhof', info: 'Lokalbahn' },
      // Lokalbahn S1/S11
      { id: 'oberndorf', name: 'Oberndorf bei Salzburg', info: 'Lokalbahn S1/S11' },
      { id: 'buermoos', name: 'Bürmoos', info: 'Lokalbahn S1' },
      { id: 'lamprechtshausen', name: 'Lamprechtshausen', info: 'Lokalbahn S1' },
      { id: 'trimmelkam', name: 'Trimmelkam', info: 'Lokalbahn S11' },
      // Flachgau
      { id: 'seekirchen', name: 'Seekirchen am Wallersee', info: 'S-Bahn, Bus' },
      { id: 'eugendorf', name: 'Eugendorf', info: 'S-Bahn, Bus' },
      { id: 'mattsee', name: 'Mattsee', info: 'Bus' },
      { id: 'strasswalchen', name: 'Straßwalchen', info: 'S-Bahn, Bus' },
      // Tennengau
      { id: 'hallein', name: 'Hallein', info: 'S-Bahn S3, Bus' },
      { id: 'golling', name: 'Golling-Abtenau', info: 'S-Bahn S3, Bus' },
      { id: 'kuchl', name: 'Kuchl', info: 'S-Bahn S3' },
      // Pongau
      { id: 'st-johann-im-pongau', name: 'St. Johann im Pongau', info: 'S-Bahn, REX, Bus' },
      { id: 'bischofshofen', name: 'Bischofshofen', info: 'S-Bahn, REX, IC' },
      { id: 'schwarzach-st-veit', name: 'Schwarzach-St. Veit', info: 'IC, REX, S-Bahn' },
      { id: 'bad-gastein', name: 'Bad Gastein', info: 'IC, REX, Bus' },
      { id: 'bad-hofgastein', name: 'Bad Hofgastein', info: 'REX, Bus' },
      // Pinzgau
      { id: 'zell-am-see', name: 'Zell am See', info: 'IC, REX, Pinzgauer Bahn' },
      { id: 'kaprun', name: 'Kaprun', info: 'Pinzgauer Bahn, Bus' },
      { id: 'mittersill', name: 'Mittersill', info: 'Pinzgauer Bahn, Bus' },
      { id: 'krimml', name: 'Krimml', info: 'Pinzgauer Bahn Endstation' },
      { id: 'saalfelden', name: 'Saalfelden am Steinernen Meer', info: 'REX, S-Bahn, Bus' },
      { id: 'leogang', name: 'Leogang', info: 'Bus' },
      { id: 'lofer', name: 'Lofer', info: 'Bus' },
      // Lungau
      { id: 'tamsweg', name: 'Tamsweg', info: 'Bus' },
      { id: 'mauterndorf', name: 'Mauterndorf', info: 'Bus' },
      { id: 'st-michael-im-lungau', name: 'St. Michael im Lungau', info: 'Bus' }
    ]
  }
};

const SEARCH_API = 'https://api.straba.at/api/v1/stops/search';
const DEPARTURES_API = 'https://api.straba.at/api/v1/wl/departures';
const WIEN_DATA_URL = 'https://straba-983965425140.europe-west3.run.app/search/';

// ==================== STATE ====================
let currentStep = 'region';
let selectedRegion = null;
let selectedNetwork = null;
let selectedStop = null;
let availableLines = [];
let selectedLines = new Set();
let stations = [];
let editingStationIndex = null;  // Index der Station die bearbeitet wird (null = neue Station)
let hasExistingConfig = false;   // True wenn Config vom Gerät geladen wurde
let wienData = null;
let searchTimeout = null;

// Wien-Modus (Linie → Station → Richtung)
let wienSelectedLine = null;
let wienSelectedStation = null;
let wienSelectedDirections = [];
let wienOtherLines = [];

// Journey-Modus (für DB)
let journeyFromStop = null;
let journeyToStop = null;
let selectedProducts = new Set();

// ==================== DOM ====================
const stepRegion = document.getElementById('stepRegion');
const stepNetwork = document.getElementById('stepNetwork');
const stepSearch = document.getElementById('stepSearch');
const stepLines = document.getElementById('stepLines');
const networkGrid = document.getElementById('networkGrid');
const searchInput = document.getElementById('searchInput');
const searchSpinner = document.getElementById('searchSpinner');
const searchResults = document.getElementById('searchResults');
const linesLoading = document.getElementById('linesLoading');
const linesContainer = document.getElementById('linesContainer');
const linesList = document.getElementById('linesList');
const addStationBtn = document.getElementById('addStationBtn');
const stationsContainer = document.getElementById('stationsContainer');
const emptyState = document.getElementById('emptyState');
const stationCount = document.getElementById('stationCount');
const saveBtn = document.getElementById('saveBtn');
const breadcrumb = document.getElementById('breadcrumb');

// ==================== NAVIGATION ====================
function showStep(step) {
  currentStep = step;
  stepRegion.classList.toggle('hidden', step !== 'region');
  stepNetwork.classList.toggle('hidden', step !== 'network');
  stepSearch.classList.toggle('hidden', step !== 'search');
  stepLines.classList.toggle('hidden', step !== 'lines');

  // Grouping Step entfernt - jetzt nur im Feintuning

  // Journey-Modus Steps
  const stepJourneySearch = document.getElementById('stepJourneySearch');
  if (stepJourneySearch) stepJourneySearch.classList.toggle('hidden', step !== 'journeySearch');

  // Wien-Modus Steps
  const stepWienLine = document.getElementById('stepWienLine');
  const stepWienStation = document.getElementById('stepWienStation');
  const stepWienDirection = document.getElementById('stepWienDirection');
  if (stepWienLine) stepWienLine.classList.toggle('hidden', step !== 'wienLine');
  if (stepWienStation) stepWienStation.classList.toggle('hidden', step !== 'wienStation');
  if (stepWienDirection) stepWienDirection.classList.toggle('hidden', step !== 'wienDirection');

  updateBreadcrumb();
}

function updateBreadcrumb() {
  let html = '';
  
  html += `<span class="breadcrumb-item ${currentStep === 'region' ? 'active' : ''}" onclick="goBack('region')">Region</span>`;
  
  if (selectedRegion) {
    html += `<span class="breadcrumb-sep">›</span>`;
    html += `<span class="breadcrumb-item ${currentStep === 'network' ? 'active' : ''}" onclick="goBack('network')">${REGIONS[selectedRegion].name}</span>`;
  }
  
  if (selectedNetwork) {
    html += `<span class="breadcrumb-sep">›</span>`;
    const isJourney = NETWORKS[selectedNetwork].isJourneyBased;
    const isWien = selectedNetwork === 'WL';
    const backStep = isWien ? 'wienLine' : (isJourney ? 'journeySearch' : 'search');
    const isActive = currentStep === 'search' || currentStep === 'journeySearch' || currentStep === 'wienLine';
    html += `<span class="breadcrumb-item ${isActive ? 'active' : ''}" onclick="goBack('${backStep}')">${NETWORKS[selectedNetwork].name}</span>`;
  }

  // Wien: Linie und Station im Breadcrumb
  if (selectedNetwork === 'WL' && wienSelectedLine) {
    html += `<span class="breadcrumb-sep">›</span>`;
    html += `<span class="breadcrumb-item ${currentStep === 'wienStation' ? 'active' : ''}" onclick="goBack('wienStation')">${wienSelectedLine.lineName}</span>`;
  }
  if (selectedNetwork === 'WL' && wienSelectedStation && currentStep === 'wienDirection') {
    html += `<span class="breadcrumb-sep">›</span>`;
    html += `<span class="breadcrumb-item active">${wienSelectedStation.name}</span>`;
  }

  if (selectedStop && currentStep === 'lines') {
    html += `<span class="breadcrumb-sep">›</span>`;
    html += `<span class="breadcrumb-item active">${selectedStop.name}</span>`;
  }

  breadcrumb.innerHTML = html;
}

function goBack(step) {
  if (step === 'region') {
    selectedRegion = null;
    selectedNetwork = null;
    selectedStop = null;
    journeyFromStop = null;
    journeyToStop = null;
    selectedProducts = new Set();
    wienSelectedLine = null;
    wienSelectedStation = null;
    wienSelectedDirections = [];
    wienOtherLines = [];
  } else if (step === 'network') {
    selectedNetwork = null;
    selectedStop = null;
    journeyFromStop = null;
    journeyToStop = null;
    selectedProducts = new Set();
    wienSelectedLine = null;
    wienSelectedStation = null;
    wienSelectedDirections = [];
    wienOtherLines = [];
    // Hide products section
    const productsSection = document.getElementById('journeyProductsSection');
    if (productsSection) productsSection.classList.add('hidden');
  } else if (step === 'search') {
    selectedStop = null;
    searchInput.value = '';
    searchResults.classList.remove('show');
  } else if (step === 'journeySearch') {
    selectedProducts = new Set();
    // Hide products section when going back
    const productsSection = document.getElementById('journeyProductsSection');
    if (productsSection) productsSection.classList.add('hidden');
  } else if (step === 'wienLine') {
    wienSelectedLine = null;
    wienSelectedStation = null;
    wienSelectedDirections = [];
    wienOtherLines = [];
    document.getElementById('wienLineInput').value = '';
    showWienLineDropdown('');
  } else if (step === 'wienStation') {
    wienSelectedStation = null;
    wienSelectedDirections = [];
    wienOtherLines = [];
    document.getElementById('wienStationInput').value = '';
    showWienStationDropdown('');
  } else if (step === 'lines') {
    // Going back from grouping to lines
    lineGroups = [];
    groupingEnabled = false;
  }
  showStep(step);
}

// ==================== REGION SELECTION ====================
function selectRegion(region) {
  if (REGIONS[region].networks.length === 0) return;
  
  selectedRegion = region;
  renderNetworkGrid();
  showStep('network');
}

function renderNetworkGrid() {
  const networks = REGIONS[selectedRegion].networks;
  
  networkGrid.innerHTML = networks.map(id => {
    const net = NETWORKS[id];
    const badgeClass = id.toLowerCase();
    return `
      <button class="selection-btn" onclick="selectNetwork('${id}')">
        <div class="network-badge ${badgeClass}">${net.shortName || id}</div>
        <div class="name">${net.name}</div>
        <div class="desc">${net.desc}</div>
      </button>
    `;
  }).join('');
}

// ==================== NETWORK SELECTION ====================
function selectNetwork(network) {
  selectedNetwork = network;
  const netConfig = NETWORKS[network];

  // Wien: Eigener Flow (Linie → Station → Richtung)
  if (network === 'WL') {
    wienSelectedLine = null;
    wienSelectedStation = null;
    wienSelectedDirections = [];
    wienOtherLines = [];

    // Reset Wien inputs
    const lineInput = document.getElementById('wienLineInput');
    const stationInput = document.getElementById('wienStationInput');
    if (lineInput) lineInput.value = '';
    if (stationInput) stationInput.value = '';
    document.getElementById('wienLineResults').classList.remove('show');
    document.getElementById('wienStationResults').classList.remove('show');

    // Lade Wien-Daten falls noch nicht geladen
    if (!wienData) {
      loadWienData().then(() => {
        showWienLineDropdown('');
      });
    } else {
      setTimeout(() => showWienLineDropdown(''), 50);
    }

    showStep('wienLine');
    document.getElementById('wienLineInput').focus();
    return;
  }

  // Journey-basierte Netzwerke (DB)
  if (netConfig.isJourneyBased) {
    journeyFromStop = null;
    journeyToStop = null;
    selectedProducts = new Set();

    // Reset form
    const fromInput = document.getElementById('journeyFromInput');
    const toInput = document.getElementById('journeyToInput');
    const fromSelected = document.getElementById('journeyFromSelected');
    const toSelected = document.getElementById('journeyToSelected');
    const fromResults = document.getElementById('journeyFromResults');
    const toResults = document.getElementById('journeyToResults');
    const productsSection = document.getElementById('journeyProductsSection');

    if (fromInput) {
      fromInput.value = '';
      fromInput.placeholder = netConfig.placeholder;
      fromInput.parentElement.classList.remove('hidden');
    }
    if (toInput) {
      toInput.value = '';
      toInput.placeholder = netConfig.placeholder;
      toInput.parentElement.classList.remove('hidden');
    }
    if (fromSelected) fromSelected.classList.add('hidden');
    if (toSelected) toSelected.classList.add('hidden');
    if (fromResults) fromResults.classList.remove('show');
    if (toResults) toResults.classList.remove('show');
    if (productsSection) productsSection.classList.add('hidden');

    showStep('journeySearch');
    return;
  }
  
  // Normale Netzwerke
  searchInput.placeholder = netConfig.placeholder;
  searchInput.value = '';
  searchResults.classList.remove('show');
  
  if (network === 'WL' && !wienData) {
    loadWienData();
  }
  
  showStep('search');
  searchInput.focus();
}

// ==================== WIEN DATA ====================
async function loadWienData() {
  try {
    const response = await fetch(WIEN_DATA_URL);
    wienData = await response.json();
  } catch (e) {
    console.error('Failed to load Wien data:', e);
  }
}

// ==================== WIEN FLOW (Linie → Station → Richtung) ====================

// Event Listeners für Wien-Inputs
document.addEventListener('DOMContentLoaded', () => {
  const wienLineInput = document.getElementById('wienLineInput');
  const wienStationInput = document.getElementById('wienStationInput');

  if (wienLineInput) {
    wienLineInput.addEventListener('input', function() {
      showWienLineDropdown(this.value);
    });
    wienLineInput.addEventListener('focus', function() {
      showWienLineDropdown(this.value);
    });
  }

  if (wienStationInput) {
    wienStationInput.addEventListener('input', function() {
      if (wienSelectedLine) showWienStationDropdown(this.value);
    });
    wienStationInput.addEventListener('focus', function() {
      if (wienSelectedLine) showWienStationDropdown(this.value);
    });
  }
});

// Endstationen einer Linie ermitteln
function getWienLineEndpoints(line) {
  if (!Array.isArray(line.lineStation) || line.lineStation.length === 0) return '';

  const patternIds = [...new Set(line.lineStation.map(s => s.patternID))];
  const endStations = patternIds.map(patternId => {
    const stationsOfPattern = line.lineStation.filter(s => s.patternID === patternId);
    if (stationsOfPattern.length > 0) {
      return stationsOfPattern[stationsOfPattern.length - 1]?.station?.stationName || '';
    }
    return '';
  }).filter(name => name !== '');

  const uniqueEndStations = [...new Set(endStations)];
  if (uniqueEndStations.length >= 2) {
    return `${uniqueEndStations[0]} ↔ ${uniqueEndStations[1]}`;
  } else if (uniqueEndStations.length === 1) {
    return `→ ${uniqueEndStations[0]}`;
  }
  return '';
}

// Linie-Dropdown anzeigen
function showWienLineDropdown(query) {
  if (!wienData) return;
  query = query.toLowerCase().trim();

  let filtered = wienData.filter(line =>
    Array.isArray(line.lineStation) && line.lineStation.length > 0
  );

  if (query.length > 0) {
    filtered = filtered.filter(line =>
      line.lineName.toLowerCase().includes(query)
    );
  }

  // Sortierung: U-Bahnen, dann Tram/Bus, Nachtbusse zuletzt
  filtered.sort((a, b) => {
    const aName = a.lineName;
    const bName = b.lineName;

    // Exakte Treffer oben
    const aExact = aName.toLowerCase() === query;
    const bExact = bName.toLowerCase() === query;
    if (aExact && !bExact) return -1;
    if (!aExact && bExact) return 1;

    // Kategorie: 1=U-Bahn, 2=Tram/Bus, 3=Nachtbus
    const getCategory = (name) => {
      if (name.startsWith('U')) return 1;
      if (name.startsWith('N')) return 3;
      return 2;
    };

    const aCat = getCategory(aName);
    const bCat = getCategory(bName);
    if (aCat !== bCat) return aCat - bCat;

    // Numerisch sortieren
    const aNum = parseInt(aName.replace(/\D/g, '')) || 999;
    const bNum = parseInt(bName.replace(/\D/g, '')) || 999;
    if (aNum !== bNum) return aNum - bNum;

    return aName.localeCompare(bName, 'de');
  });

  // Bei exakter Übereinstimmung nur diesen
  if (query.length > 0 && filtered.length > 0 && filtered[0].lineName.toLowerCase() === query) {
    filtered = filtered.slice(0, 1);
  } else {
    filtered = filtered.slice(0, 100);
  }

  const resultsList = document.getElementById('wienLineResults');

  if (filtered.length === 0) {
    resultsList.innerHTML = '<div class="no-results" style="padding:16px;text-align:center;color:#888;">Keine Linie gefunden</div>';
  } else {
    resultsList.innerHTML = filtered.map(line => {
      const endpoints = getWienLineEndpoints(line);
      const lineType = line.lineName.startsWith('U') ? 'type-metro' : (line.lineName.startsWith('N') ? 'type-bus' : (/^\d+$/.test(line.lineName) || /^\d+[A-Z]$/.test(line.lineName) ? 'type-tram' : 'type-bus'));

      return `
        <div class="search-result-item" onclick="selectWienLine(${line.lineID})">
          <div style="display:flex;align-items:center;gap:12px;">
            <span class="line-badge ${lineType}" style="padding:6px 12px;border-radius:6px;font-weight:700;font-size:14px;min-width:50px;text-align:center;">${line.lineName}</span>
            <div>
              <div class="stop-name" style="font-weight:600;">${line.lineName}</div>
              ${endpoints ? `<div class="stop-info" style="font-size:12px;color:#888;">${endpoints}</div>` : ''}
            </div>
          </div>
        </div>
      `;
    }).join('');
  }

  resultsList.classList.add('show');
}

// Linie auswählen
function selectWienLine(lineID) {
  wienSelectedLine = wienData.find(l => l.lineID === lineID);
  if (!wienSelectedLine) return;

  document.getElementById('wienLineInput').value = wienSelectedLine.lineName;
  document.getElementById('wienLineResults').classList.remove('show');

  // Titel aktualisieren
  document.getElementById('wienSelectedLineName').innerHTML = `<span class="line-badge type-${wienSelectedLine.lineName.startsWith('U') ? 'metro' : 'tram'}" style="padding:6px 12px;border-radius:6px;font-weight:700;margin-right:8px;">${wienSelectedLine.lineName}</span> Station wählen`;

  // Reset Station selection
  wienSelectedStation = null;
  wienSelectedDirections = [];
  wienOtherLines = [];
  document.getElementById('wienStationInput').value = '';

  showStep('wienStation');
  document.getElementById('wienStationInput').focus();
  setTimeout(() => showWienStationDropdown(''), 50);
}

// Stationsnamen normalisieren
function normalizeStationName(name) {
  return name.replace(/\s*[\/,]\s*/g, ' ').replace(/\s+/g, ' ').trim().toLowerCase();
}

// Station-Dropdown anzeigen
function showWienStationDropdown(inputValue) {
  if (!wienSelectedLine) return;
  const query = inputValue.toLowerCase().trim();

  // Gruppiere Stationen nach normalisiertem Namen
  const stationsByName = new Map();

  if (Array.isArray(wienSelectedLine.lineStation)) {
    wienSelectedLine.lineStation.forEach(item => {
      const station = item.station;
      if (station && station.stationName && station.stationID) {
        const normalizedName = normalizeStationName(station.stationName);

        if (!stationsByName.has(normalizedName)) {
          stationsByName.set(normalizedName, {
            originalNames: [station.stationName],
            stopIds: new Set(),
            directions: []
          });
        }

        const entry = stationsByName.get(normalizedName);
        if (!entry.originalNames.includes(station.stationName)) {
          entry.originalNames.push(station.stationName);
        }
        entry.stopIds.add(station.stationID);

        const towards = getWienDirectionName(wienSelectedLine, item.patternID);
        const alreadyExists = entry.directions.some(d => d.towards === towards);
        if (!alreadyExists) {
          entry.directions.push({
            patternID: item.patternID,
            stopId: station.stationID,
            towards: towards
          });
        }
      }
    });
  }

  let stationsList = Array.from(stationsByName.values()).map(s => ({
    name: s.originalNames.find(n => n.includes('/')) || s.originalNames[0],
    originalNames: s.originalNames,
    stopIds: Array.from(s.stopIds),
    directions: s.directions
  })).sort((a, b) => a.name.localeCompare(b.name, 'de'));

  if (query.length > 0) {
    stationsList = stationsList.filter(s =>
      s.name.toLowerCase().includes(query) ||
      s.originalNames.some(n => n.toLowerCase().includes(query))
    );
  }

  const resultsList = document.getElementById('wienStationResults');

  if (stationsList.length === 0) {
    resultsList.innerHTML = '<div class="no-results" style="padding:16px;text-align:center;color:#888;">Keine Station gefunden</div>';
  } else {
    resultsList.innerHTML = stationsList.map(station => {
      const dirInfo = station.directions.length === 1
        ? `→ ${station.directions[0].towards}`
        : `${station.directions.length} Richtungen`;

      return `
        <div class="search-result-item" onclick='selectWienStation(${JSON.stringify(station).replace(/'/g, "&#39;")})'>
          <div class="stop-name">${station.name}</div>
          <div class="stop-info">${dirInfo}</div>
        </div>
      `;
    }).join('');
  }

  resultsList.classList.add('show');
}

// Richtungsname ermitteln (Endstation)
function getWienDirectionName(line, patternID) {
  if (!Array.isArray(line.lineStation)) return 'Unbekannt';
  const stationsWithPattern = line.lineStation.filter(s => s.patternID === patternID);
  if (stationsWithPattern.length > 0) {
    return stationsWithPattern[stationsWithPattern.length - 1]?.station?.stationName || 'Unbekannt';
  }
  return 'Unbekannt';
}

// Station auswählen
function selectWienStation(station) {
  wienSelectedStation = station;
  document.getElementById('wienStationInput').value = station.name;
  document.getElementById('wienStationResults').classList.remove('show');

  wienSelectedDirections = [];
  wienOtherLines = [];

  // Titel aktualisieren
  document.getElementById('wienDirectionTitle').innerHTML = `📍 ${station.name}`;
  document.getElementById('wienDirectionInfo').textContent = `Linie ${wienSelectedLine.lineName} - Wähle die Richtung(en)`;

  // Richtungen anzeigen
  const dirList = document.getElementById('wienDirectionList');
  const uniqueDirections = station.directions;

  if (uniqueDirections.length === 1) {
    // Nur eine Richtung - automatisch auswählen
    wienSelectedDirections = [uniqueDirections[0]];
    dirList.innerHTML = `
      <div class="line-group">
        <div class="line-group-header" style="background:#e8f5e9;">
          <span class="line-badge type-metro" style="padding:6px 12px;border-radius:6px;font-weight:700;">${wienSelectedLine.lineName}</span>
          <span class="line-name">→ ${uniqueDirections[0].towards}</span>
          <span style="margin-left:auto;color:#4caf50;font-weight:600;">✓ Ausgewählt</span>
        </div>
      </div>
    `;
    document.getElementById('wienAddStationBtn').disabled = false;
    showWienOtherLines();
  } else {
    // Mehrere Richtungen - Checkboxen
    dirList.innerHTML = uniqueDirections.map((dir, idx) => `
      <div class="line-group" id="wienDir_${idx}">
        <div class="line-group-header" onclick="toggleWienDirection(${idx}, ${dir.patternID}, ${dir.stopId}, '${dir.towards.replace(/'/g, "\\'")}')">
          <input type="checkbox" id="wienDirCheck_${idx}" style="width:18px;height:18px;">
          <span class="line-badge type-metro" style="padding:6px 12px;border-radius:6px;font-weight:700;">${wienSelectedLine.lineName}</span>
          <span class="line-name">→ ${dir.towards}</span>
        </div>
      </div>
    `).join('');
    document.getElementById('wienAddStationBtn').disabled = true;
  }

  showStep('wienDirection');
}

// Richtung togglen
function toggleWienDirection(idx, patternID, stopId, towards) {
  const checkbox = document.getElementById(`wienDirCheck_${idx}`);
  const container = document.getElementById(`wienDir_${idx}`);
  checkbox.checked = !checkbox.checked;

  if (checkbox.checked) {
    container.querySelector('.line-group-header').style.background = '#e8f5e9';
    wienSelectedDirections.push({ patternID, stopId, towards });
  } else {
    container.querySelector('.line-group-header').style.background = '#f8f8f8';
    wienSelectedDirections = wienSelectedDirections.filter(d => d.patternID !== patternID);
  }

  document.getElementById('wienAddStationBtn').disabled = wienSelectedDirections.length === 0;

  // Andere Linien anzeigen wenn mindestens eine Richtung gewählt
  if (wienSelectedDirections.length > 0) {
    showWienOtherLines();
  } else {
    document.getElementById('wienOtherLinesSection').style.display = 'none';
  }
}

// Andere Linien an dieser Station anzeigen
function showWienOtherLines() {
  if (!wienSelectedStation || wienSelectedDirections.length === 0) return;

  const stopIds = wienSelectedStation.stopIds;
  const currentLineName = wienSelectedLine.lineName;

  // Finde andere Linien die an diesen StopIds halten
  const otherLines = [];

  wienData.forEach(line => {
    if (line.lineName === currentLineName) return;

    if (Array.isArray(line.lineStation)) {
      line.lineStation.forEach(item => {
        if (stopIds.includes(item.station?.stationID)) {
          const towards = getWienDirectionName(line, item.patternID);
          const alreadyExists = otherLines.some(ol =>
            ol.lineName === line.lineName && ol.towards === towards
          );
          if (!alreadyExists) {
            otherLines.push({
              lineID: line.lineID,
              lineName: line.lineName,
              patternID: item.patternID,
              stopId: item.station.stationID,
              towards: towards
            });
          }
        }
      });
    }
  });

  const section = document.getElementById('wienOtherLinesSection');
  const list = document.getElementById('wienOtherLinesList');

  if (otherLines.length === 0) {
    section.style.display = 'none';
    return;
  }

  // Sortiere nach Linienname
  otherLines.sort((a, b) => {
    const aNum = parseInt(a.lineName.replace(/\D/g, '')) || 999;
    const bNum = parseInt(b.lineName.replace(/\D/g, '')) || 999;
    return aNum - bNum;
  });

  list.innerHTML = otherLines.map((ol, idx) => {
    const lineType = ol.lineName.startsWith('U') ? 'type-metro' : (/^\d+$/.test(ol.lineName) || /^\d+[A-Z]$/.test(ol.lineName) ? 'type-tram' : 'type-bus');
    return `
      <div class="line-group" id="wienOther_${idx}" style="margin-bottom:8px;">
        <div class="line-group-header" onclick="toggleWienOtherLine(${idx}, ${ol.lineID}, '${ol.lineName}', ${ol.patternID}, ${ol.stopId}, '${ol.towards.replace(/'/g, "\\'")}')">
          <input type="checkbox" id="wienOtherCheck_${idx}" style="width:18px;height:18px;">
          <span class="line-badge ${lineType}" style="padding:6px 12px;border-radius:6px;font-weight:700;">${ol.lineName}</span>
          <span class="line-name">→ ${ol.towards}</span>
        </div>
      </div>
    `;
  }).join('');

  section.style.display = 'block';
}

// Andere Linie togglen
function toggleWienOtherLine(idx, lineID, lineName, patternID, stopId, towards) {
  const checkbox = document.getElementById(`wienOtherCheck_${idx}`);
  const container = document.getElementById(`wienOther_${idx}`);
  checkbox.checked = !checkbox.checked;

  if (checkbox.checked) {
    container.querySelector('.line-group-header').style.background = '#e3f2fd';
    wienOtherLines.push({ lineID, lineName, patternID, stopId, towards });
  } else {
    container.querySelector('.line-group-header').style.background = '#f8f8f8';
    wienOtherLines = wienOtherLines.filter(ol => !(ol.lineID === lineID && ol.patternID === patternID));
  }
}

// Wien Station hinzufügen
function addWienStation() {
  if (!wienSelectedLine || !wienSelectedStation || wienSelectedDirections.length === 0) return;

  // Sammle alle Stop-IDs
  const stopIds = wienSelectedDirections.map(d => d.stopId);
  wienOtherLines.forEach(ol => {
    if (!stopIds.includes(ol.stopId)) stopIds.push(ol.stopId);
  });

  // Liniennamen sammeln
  const lineNames = [wienSelectedLine.lineName];
  wienOtherLines.forEach(ol => {
    if (!lineNames.includes(ol.lineName)) lineNames.push(ol.lineName);
  });

  // fullId für Wien: nur die numerischen StopIDs (so erwartet der ESP32)
  const fullId = stopIds.join(',');

  // Check ob schon vorhanden
  if (stations.some(s => s.fullId === fullId && s.network === 'WL')) {
    alert('Diese Station ist bereits hinzugefügt!');
    return;
  }

  // Ausgewaehlte Richtungen speichern (Linie + towards + richtungsId/patternID)
  const selectedDirections = [];
  wienSelectedDirections.forEach(d => {
    selectedDirections.push({
      line: wienSelectedLine.lineName,
      towards: d.towards || '',
      type: 'metro',
      richtungsId: String(d.patternID || '')  // Wien patternID = richtungsId
    });
  });
  wienOtherLines.forEach(ol => {
    selectedDirections.push({
      line: ol.lineName,
      towards: ol.towards || '',
      type: ol.lineName.startsWith('U') ? 'metro' : 'tram',
      richtungsId: String(ol.patternID || '')  // Wien patternID = richtungsId
    });
  });

  stations.push({
    network: 'WL',
    networkName: 'Wiener Linien',
    stopId: stopIds.join(','),
    stopName: wienSelectedStation.name,
    filter: lineNames.join(','),
    fullId: fullId,  // Nur numerische IDs, kein Prefix
    isExisting: false,
    directions: selectedDirections  // Speichert Linie + Richtung
  });

  // Reset und zurück
  wienSelectedLine = null;
  wienSelectedStation = null;
  wienSelectedDirections = [];
  wienOtherLines = [];

  goBack('region');
  updateStationsList();
}

// ==================== SEARCH ====================
searchInput.addEventListener('input', function() {
  const query = this.value.trim();
  if (searchTimeout) clearTimeout(searchTimeout);
  
  const netConfig = NETWORKS[selectedNetwork];
  
  // Bei static_list: auch bei leerem Query alle anzeigen
  if (netConfig?.searchType === 'static_list') {
    if (query.length === 0) {
      displaySearchResults(netConfig.stations);
      return;
    }
    searchTimeout = setTimeout(() => performSearch(query), 100);
    return;
  }
  
  if (query.length < 2) {
    searchResults.classList.remove('show');
    return;
  }
  
  searchTimeout = setTimeout(() => performSearch(query), 300);
});

// Bei static_list: Klick ins Suchfeld zeigt alle Stationen
searchInput.addEventListener('focus', function() {
  const netConfig = NETWORKS[selectedNetwork];
  if (netConfig?.searchType === 'static_list' && this.value.trim().length === 0) {
    displaySearchResults(netConfig.stations);
  }
});

async function performSearch(query) {
  if (!selectedNetwork) return;
  
  searchSpinner.classList.add('show');
  
  try {
    let results = [];
    const netConfig = NETWORKS[selectedNetwork];
    
    if (netConfig.searchType === 'wien_json') {
      results = searchWien(query);
    } else if (netConfig.searchType === 'static_list') {
      results = searchStaticList(netConfig.stations, query);
    } else {
      results = await searchViaProxy(selectedNetwork, query);
    }
    
    displaySearchResults(results);
  } catch (e) {
    console.error('Search error:', e);
    searchResults.innerHTML = '<div class="no-results">Fehler bei der Suche</div>';
    searchResults.classList.add('show');
  } finally {
    searchSpinner.classList.remove('show');
  }
}

function searchStaticList(stations, query) {
  if (!stations) return [];
  if (!query || query.length === 0) return stations.slice(0, 30); // Alle anzeigen (max 30)
  
  const q = query.toLowerCase();
  return stations
    .filter(s => s.name.toLowerCase().includes(q) || (s.info && s.info.toLowerCase().includes(q)))
    .slice(0, 15);
}

function searchWien(query) {
  if (!wienData) return [];
  
  const q = query.toLowerCase();
  const stationsMap = new Map();
  
  wienData.forEach(line => {
    if (!Array.isArray(line.lineStation)) return;
    line.lineStation.forEach(item => {
      const station = item.station;
      if (!station || !station.stationName || !station.stationID) return;
      if (station.stationName.toLowerCase().includes(q)) {
        const id = station.stationID;
        if (!stationsMap.has(id)) {
          stationsMap.set(id, { id: String(id), name: station.stationName, lines: new Set() });
        }
        stationsMap.get(id).lines.add(line.lineName);
      }
    });
  });
  
  return Array.from(stationsMap.values())
    .map(s => ({
      id: s.id,
      name: s.name,
      info: Array.from(s.lines).slice(0, 5).join(', ') + (s.lines.size > 5 ? '...' : '')
    }))
    .slice(0, 15);
}

async function searchViaProxy(network, query) {
  const params = new URLSearchParams({ network, q: query });
  const response = await fetch(`${SEARCH_API}?${params}`);
  const data = await response.json();
  return (data.stops || []).map(s => ({ id: s.id, name: s.name, info: s.info || '' }));
}

function displaySearchResults(results) {
  if (results.length === 0) {
    searchResults.innerHTML = '<div class="no-results">Keine Stationen gefunden</div>';
  } else {
    searchResults.innerHTML = results.map(r => `
      <div class="search-result-item" onclick="selectStop('${r.id}', '${r.name.replace(/'/g, "\\'")}')">
        <div class="stop-name">${r.name}</div>
        <div class="stop-info">${r.info || `ID: ${r.id}`}</div>
      </div>
    `).join('');
  }
  searchResults.classList.add('show');
}

// ==================== STOP SELECTION ====================
async function selectStop(id, name) {
  const fullId = `${selectedNetwork}:${id}`;

  // Prüfen ob diese Station schon existiert - dann automatisch Bearbeiten-Modus
  const existingIndex = stations.findIndex(s => s.fullId === fullId);
  if (existingIndex !== -1) {
    const existingStation = stations[existingIndex];
    editingStationIndex = existingIndex;
    await selectStopForEdit(id, name, existingStation.directions || [], existingStation.filter || '');
    return;
  }

  selectedStop = { id, name };
  selectedLines = new Set();
  availableLines = [];
  editingStationIndex = null;  // Sicherstellen dass wir nicht im Bearbeiten-Modus sind

  document.getElementById('selectedStationName').textContent = name;
  document.getElementById('selectedStationInfo').textContent = `${NETWORKS[selectedNetwork].name} · ID: ${id}`;

  searchResults.classList.remove('show');
  showStep('lines');

  // Load departures to get available lines
  linesLoading.classList.remove('hidden');
  linesContainer.classList.add('hidden');
  addStationBtn.disabled = true;
  addStationBtn.textContent = 'Weiter';  // Button-Text zurücksetzen

  try {
    const response = await fetch(`${DEPARTURES_API}?stopId=${fullId}`);
    const data = await response.json();

    extractLines(data);
    renderLines();

    linesLoading.classList.add('hidden');
    linesContainer.classList.remove('hidden');
  } catch (e) {
    console.error('Failed to load departures:', e);
    linesLoading.innerHTML = '<div style="color:#d32f2f">Fehler beim Laden der Linien</div>';
  }
}

function extractLines(data) {
  const linesMap = new Map();

  // BODO Filter: Nur reine Zahlen oder erlaubte Buslinien
  // Erlaubt: Reine Zahlen (1, 2, 7, 22/3, etc.), S20-S199 (Schnellbusse), R25-R199 (Regiobusse)
  function isBodoAllowed(name) {
    const trimmed = name.trim();
    // Reine Zahlen sind erlaubt (auch mit Schrägstrich wie 22/3)
    if (/^[\d\/]+$/.test(trimmed)) return true;
    // Schnellbusse S20-S199
    const sMatch = trimmed.match(/^S\s*(\d+)$/i);
    if (sMatch) {
      const num = parseInt(sMatch[1]);
      if (num >= 20 && num <= 199) return true;
    }
    // Regiobusse R25-R199
    const rMatch = trimmed.match(/^R\s*(\d+)$/i);
    if (rMatch) {
      const num = parseInt(rMatch[1]);
      if (num >= 25 && num <= 199) return true;
    }
    // Alles andere (MEX, RS, RE, ICE, etc.) ist nicht erlaubt
    return false;
  }

  if (data.data && data.data.monitors) {
    data.data.monitors.forEach(monitor => {
      if (monitor.lines) {
        monitor.lines.forEach(line => {
          const name = line.name || '?';
          const towards = line.towards || '';
          const key = `${name}|${towards}`;

          // Bei BODO: Nur erlaubte Linien anzeigen
          if (selectedNetwork === 'BODO' && !isBodoAllowed(name)) {
            return; // Nicht erlaubte Linie überspringen
          }

          if (!linesMap.has(key)) {
            linesMap.set(key, { name, towards, type: line.type || '' });
          }
        });
      }
    });
  }

  availableLines = Array.from(linesMap.values());
  
  availableLines.sort((a, b) => {
    const aNum = parseInt(a.name) || 999;
    const bNum = parseInt(b.name) || 999;
    if (aNum !== bNum) return aNum - bNum;
    return a.name.localeCompare(b.name);
  });
}

function renderLines() {
  if (availableLines.length === 0) {
    linesList.innerHTML = '<div class="no-results">Keine Abfahrten gefunden</div>';
    return;
  }
  
  // Group by line name
  const groups = new Map();
  availableLines.forEach((line, idx) => {
    if (!groups.has(line.name)) {
      groups.set(line.name, []);
    }
    groups.get(line.name).push({ ...line, idx });
  });
  
  let html = '';
  groups.forEach((directions, lineName) => {
    const allSelected = directions.every(d => selectedLines.has(d.idx));
    const someSelected = directions.some(d => selectedLines.has(d.idx));
    const lineType = directions[0]?.type || '';
    const badgeClass = getLineTypeClass(lineType, lineName);
    
    html += `
      <div class="line-group">
        <div class="line-group-header">
          <div class="line-badge ${badgeClass}">${lineName}</div>
          <div class="line-name">Linie ${lineName}</div>
          <button class="line-toggle" onclick="toggleLineGroup('${lineName}')">${allSelected ? 'Abwählen' : 'Alle'}</button>
        </div>
        <div class="line-directions">
    `;
    
    directions.forEach(dir => {
      const selected = selectedLines.has(dir.idx);
      html += `
        <div class="direction-option ${selected ? 'selected' : ''}" onclick="toggleLine(${dir.idx})">
          <div class="checkbox">${selected ? '✓' : ''}</div>
          <div class="direction-text">${dir.towards || 'Alle Richtungen'}</div>
        </div>
      `;
    });
    
    html += `
        </div>
      </div>
    `;
  });
  
  linesList.innerHTML = html;
  updateAddButton();
  updateSelectAllButton();
}

function getLineTypeClass(type, lineName) {
  // Normalize type
  const t = (type || '').toLowerCase();
  
  // 1. Wenn API einen klaren Typ liefert, verwende diesen
  
  // Tram / Straßenbahn
  if (t.includes('tram') || t.includes('strassenbahn') || t === 'pttram' || t === 'pttramwlb') {
    return 'type-tram';
  }
  
  // U-Bahn / Metro
  if (t.includes('metro') || t.includes('ubahn') || t === 'ptmetro') {
    return 'type-metro';
  }
  
  // S-Bahn
  if (t.includes('suburban') || t === 'pttrains') {
    return 'type-suburban';
  }
  
  // Regional / Zug
  if (t.includes('train') || t.includes('regional') || t.includes('express') || 
      t === 'pttrain' || t === 'pttrainr') {
    return 'type-train';
  }
  
  // O-Bus / Trolleybus (Linz)
  if (t.includes('obus') || t.includes('trolley') || t.includes('oberleitungsbus')) {
    return 'type-obus';
  }

  // Bus explizit
  if (t.includes('bus') || t === 'ptbuscity' || t === 'ptbusnight') {
    return 'type-bus';
  }
  
  // 2. Wenn kein klarer Typ, rate basierend auf Linienname
  
  // U-Bahn: U1, U2, etc.
  if (/^U\d+$/.test(lineName)) {
    return 'type-metro';
  }
  
  // S-Bahn: S1, S2, S7, etc.
  if (/^S\d+$/.test(lineName)) {
    return 'type-suburban';
  }
  
  // Zug: RE, RB, IC, EC, ICE
  if (/^(RE|RB|IC|EC|ICE|IR|R)\d*$/.test(lineName)) {
    return 'type-train';
  }
  
  // Bus: Hat Buchstaben am Ende (7A, 26A, 29B, 35A) oder ist dreistellig+
  if (/^\d+[A-Z]$/.test(lineName) || /^\d{3,}$/.test(lineName)) {
    return 'type-bus';
  }
  
  // Niedrige Nummern (1-19) ohne Buchstaben = wahrscheinlich Tram
  // (In Wien, Linz, etc. sind das typischerweise Straßenbahnlinien)
  const num = parseInt(lineName);
  if (!isNaN(num) && num >= 1 && num <= 19 && /^\d+$/.test(lineName)) {
    return 'type-tram';
  }
  
  // Linz O-Bus Linien: 41, 43, 45, 46 (ohne Buchstaben)
  if (!isNaN(num) && [41, 43, 45, 46].includes(num) && /^\d+$/.test(lineName)) {
    return 'type-obus';
  }

  // Mittlere Nummern (20-99) ohne Buchstaben = wahrscheinlich Bus
  if (!isNaN(num) && num >= 20 && num <= 99 && /^\d+$/.test(lineName)) {
    return 'type-bus';
  }

  // Default
  return 'type-default';
}

function toggleLineGroup(lineName) {
  const directions = availableLines
    .map((line, idx) => ({ ...line, idx }))
    .filter(line => line.name === lineName);
  
  const allSelected = directions.every(d => selectedLines.has(d.idx));
  
  if (allSelected) {
    directions.forEach(d => selectedLines.delete(d.idx));
  } else {
    directions.forEach(d => selectedLines.add(d.idx));
  }
  
  renderLines();
}

function toggleLine(idx) {
  if (selectedLines.has(idx)) {
    selectedLines.delete(idx);
  } else {
    selectedLines.add(idx);
  }
  renderLines();
}

function toggleSelectAll() {
  if (selectedLines.size === availableLines.length) {
    selectedLines.clear();
  } else {
    availableLines.forEach((_, idx) => selectedLines.add(idx));
  }
  renderLines();
}

function updateSelectAllButton() {
  const btn = document.getElementById('selectAllBtn');
  btn.textContent = selectedLines.size === availableLines.length ? 'Alle abwählen' : 'Alle auswählen';
}

function updateAddButton() {
  addStationBtn.disabled = selectedLines.size === 0;
}

// Gruppierung jetzt nur im Feintuning - alte Funktionen entfernt
function showGroupingStep() {
  // Direkt Station hinzufuegen - Gruppierung im Feintuning
  addStation();
}

// ==================== ADD STATION ====================
function addStation() {
  if (!selectedNetwork || !selectedStop || selectedLines.size === 0) return;

  const selectedLineNames = Array.from(selectedLines).map(idx => availableLines[idx].name);
  const uniqueLineNames = [...new Set(selectedLineNames)];
  const filter = uniqueLineNames.join(',');

  const fullId = `${selectedNetwork}:${selectedStop.id}`;

  // Ausgewaehlte Richtungen speichern (Linie + towards)
  const selectedDirections = Array.from(selectedLines).map(idx => ({
    line: availableLines[idx].name,
    towards: availableLines[idx].towards || '',
    type: availableLines[idx].type || '',
    richtungsId: availableLines[idx].richtungsId || ''
  }));

  if (editingStationIndex !== null) {
    // Bearbeiten-Modus: Bestehende Station aktualisieren
    const existingStation = stations[editingStationIndex];
    existingStation.filter = filter;
    existingStation.directions = selectedDirections;
    editingStationIndex = null;  // Reset
  } else {
    // Neu-Modus: Duplikat prüfen
    if (stations.some(s => s.fullId === fullId)) {
      alert('Diese Station ist bereits hinzugefügt!');
      return;
    }

    stations.push({
      network: selectedNetwork,
      networkName: NETWORKS[selectedNetwork].name,
      stopId: selectedStop.id,
      stopName: selectedStop.name,
      filter: filter,
      fullId: fullId,
      isExisting: false,
      directions: selectedDirections
    });
  }

  // Reset and go back
  selectedStop = null;
  selectedLines = new Set();
  goBack('region');
  updateStationsList();
}

function removeStation(idx) {
  stations.splice(idx, 1);
  updateStationsList();
}

function updateStationsList() {
  // Gruppiere Stationen nach Name und Netzwerk
  const groupedStations = new Map();
  stations.forEach((s, idx) => {
    const key = `${s.network}:${s.stopName}`;
    if (!groupedStations.has(key)) {
      groupedStations.set(key, {
        network: s.network,
        stopName: s.stopName,
        isJourney: s.isJourney,
        isExisting: s.isExisting,
        indices: [],
        filters: [],
        directions: []
      });
    }
    const group = groupedStations.get(key);
    group.indices.push(idx);
    if (s.filter) group.filters.push(s.filter);
    if (s.directions) group.directions.push(...s.directions);
  });

  // Anzahl der einzigartigen Stationen anzeigen
  stationCount.textContent = groupedStations.size;

  const openFinetuningBtn = document.getElementById('openFinetuningBtn');

  if (stations.length === 0) {
    emptyState.style.display = 'block';
    saveBtn.disabled = true;
    if (openFinetuningBtn) openFinetuningBtn.classList.add('hidden');
  } else {
    emptyState.style.display = 'none';
    saveBtn.disabled = false;
    if (openFinetuningBtn) {
      openFinetuningBtn.classList.remove('hidden');
      // Button-Text je nach Config-Status
      openFinetuningBtn.textContent = hasExistingConfig ? 'Feintuning öffnen' : 'Weiter';
    }
  }

  const chips = Array.from(groupedStations.values()).map((group) => {
    let filterLabel;
    if (group.isJourney) {
      const uniqueFilters = [...new Set(group.filters)];
      filterLabel = `Produkte: ${uniqueFilters.join(', ') || 'Alle'}`;
    } else if (group.directions && group.directions.length > 0) {
      // Zeige Linien mit Richtungen: "1 → Böfingen, 2 → Kuhberg"
      const directionLabels = group.directions.map(d => {
        if (d.towards) {
          return `${d.line} → ${d.towards}`;
        }
        return d.line;
      });
      // Unique und sortiert
      const uniqueLabels = [...new Set(directionLabels)];
      filterLabel = uniqueLabels.join(', ');
    } else {
      // Fallback: nur Liniennummern
      const uniqueFilters = [...new Set(group.filters)];
      filterLabel = `Linien: ${uniqueFilters.join(', ') || 'Alle'}`;
    }
    const badgeClass = group.network.toLowerCase();
    const firstIdx = group.indices[0];

    return `
      <div class="station-chip ${group.isExisting ? 'existing' : ''} ${group.isJourney ? 'journey' : ''}">
        <span class="network-badge ${badgeClass}">${group.network}</span>
        <div class="info">
          <div class="stop-name">${group.stopName}</div>
          <div class="stop-details">${filterLabel}</div>
        </div>
        <div class="buttons">
          <button class="edit" onclick="editStation(${firstIdx})" title="Bearbeiten">✎</button>
          <button class="delete" onclick="removeStationGroup('${group.network}:${group.stopName.replace(/'/g, "\\'")}')" title="Löschen">×</button>
        </div>
      </div>
    `;
  }).join('');

  const existingChips = stationsContainer.querySelectorAll('.station-chip');
  existingChips.forEach(c => c.remove());
  emptyState.insertAdjacentHTML('beforebegin', chips);
}

function removeStationGroup(key) {
  // Entferne alle Stationen mit diesem Key
  const [network, stopName] = [key.split(':')[0], key.split(':').slice(1).join(':')];
  stations = stations.filter(s => !(s.network === network && s.stopName === stopName));
  updateStationsList();
}

// Nächster Schritt nach Stationen-Auswahl
function handleStationsNextStep() {
  if (hasExistingConfig) {
    // Bestehende Config vom Gerät: Direkt zum Feintuning
    goToDisplayConfig();  // Erst Config berechnen
    goToFinetuning();     // Dann direkt zum Feintuning
  } else {
    // Neue Config: Zur Display-Config Seite
    goToDisplayConfig();
  }
}

async function editStation(idx) {
  const station = stations[idx];
  if (!station) return;

  // Setze Bearbeiten-Modus
  editingStationIndex = idx;

  // Setze Netzwerk
  selectedNetwork = station.network;

  if (station.network === 'WL') {
    // Wien: Lade Wien-Daten und gehe zur Linienauswahl
    editingStationIndex = null;  // Wien hat eigenen Flow
    await loadWienData();
    showStep('wienLine');
  } else {
    // Andere Netzwerke: Direkt zur Linienauswahl
    selectedStop = { id: station.stopId, name: station.stopName };
    await selectStopForEdit(station.stopId, station.stopName, station.directions || [], station.filter || '');
  }
}

// Spezielle Version von selectStop für das Bearbeiten (mit Vorauswahl)
async function selectStopForEdit(id, name, existingDirections, existingFilter) {
  selectedStop = { id, name };
  selectedLines = new Set();
  availableLines = [];

  document.getElementById('selectedStationName').textContent = name;
  document.getElementById('selectedStationInfo').textContent = `${NETWORKS[selectedNetwork].name} · ID: ${id}`;

  searchResults.classList.remove('show');
  showStep('lines');

  // Load departures to get available lines
  linesLoading.classList.remove('hidden');
  linesContainer.classList.add('hidden');
  addStationBtn.disabled = true;

  try {
    const fullId = `${selectedNetwork}:${id}`;
    const response = await fetch(`${DEPARTURES_API}?stopId=${fullId}`);
    const data = await response.json();

    extractLines(data);

    // Vorauswahl: Markiere Linien die bereits ausgewählt waren
    availableLines.forEach((line, idx) => {
      let isSelected = false;

      if (existingDirections && existingDirections.length > 0) {
        // Wenn directions vorhanden: exaktes Matching (Line + Richtung müssen übereinstimmen)
        isSelected = existingDirections.some(d => {
          // Linienname muss übereinstimmen
          if (d.line !== line.name) return false;

          // Beide haben Richtung: müssen übereinstimmen
          if (d.towards && line.towards) {
            return d.towards === line.towards;
          }

          // Gespeicherte direction hat Richtung, aber API nicht: kein Match
          // (API sollte normalerweise immer towards haben)
          if (d.towards && !line.towards) {
            return false;
          }

          // Gespeicherte direction hat KEINE Richtung: nur Linienname matchen
          // Das passiert bei alten Configs die ohne directions gespeichert wurden
          if (!d.towards) {
            return true;
          }

          return false;
        });
      } else if (existingFilter) {
        // Fallback: Nur Liniennummer prüfen (für alte Config ohne directions)
        const filterLines = existingFilter.split(',').map(l => l.trim());
        isSelected = filterLines.includes(line.name);
      }

      if (isSelected) {
        selectedLines.add(idx);
      }
    });

    renderLines();

    linesLoading.classList.add('hidden');
    linesContainer.classList.remove('hidden');

    // Button-Status und -Text aktualisieren
    addStationBtn.disabled = selectedLines.size === 0;
    addStationBtn.textContent = 'Aktualisieren';
  } catch (e) {
    console.error('Failed to load departures:', e);
    linesLoading.innerHTML = '<div style="color:#d32f2f">Fehler beim Laden der Linien</div>';
  }
}

// ==================== DISPLAY CONFIG ====================
const NETWORK_COLORS = {
  WL: { id: 1, name: 'Wiener Linien', color: '#E20613' },
  WLB: { id: 4, name: 'WLB Badner Bahn', color: '#1E4D8C' },
  LINZ: { id: 2, name: 'Linz AG', color: '#009640' },
  DB_FERN: { id: 6, name: 'DB Fernverkehr', color: '#EC0016' },
  DB_SBAHN: { id: 5, name: 'DB S-Bahn', color: '#009640' },
  BERLIN: { id: 3, name: 'VBB Berlin', color: '#F0AB00' },
  BODO: { id: 7, name: 'BODO Bodensee', color: '#005BBB' },
  SALZBURG: { id: 8, name: 'Salzburg AG', color: '#E3000F' }
};

let suggestedColor = 1;
let suggestedRows = 2;
let recommendedConfig = null;  // Vollständige empfohlene Konfiguration

// ==================== RECOMMENDED CONFIG BERECHNUNG ====================
function calculateRecommendedConfig() {
  if (stations.length === 0) return null;

  // Dominantes Netzwerk finden
  const networkCounts = {};
  stations.forEach(s => {
    networkCounts[s.network] = (networkCounts[s.network] || 0) + 1;
  });
  const dominantNetwork = Object.entries(networkCounts)
    .sort((a, b) => b[1] - a[1])[0][0];

  // Capabilities für dominantes Netzwerk
  const capabilities = CITY_CAPABILITIES[dominantNetwork] || CITY_CAPABILITIES.WL;

  // Display-Typ bestimmen
  let displayType = capabilities.defaultColour;
  let displayName = NETWORK_COLORS[dominantNetwork]?.name || 'Wiener Linien';
  let description = `Optimiert für ${NETWORKS[dominantNetwork]?.name || dominantNetwork}`;

  // Spezialfall DB: S-Bahn vs Fernverkehr
  if (dominantNetwork === 'DB') {
    const dbStations = stations.filter(s => s.network === 'DB');
    let hasSBahn = false, hasFernverkehr = false;
    dbStations.forEach(s => {
      const products = s.filter || '';
      if (products.includes('S')) hasSBahn = true;
      if (/ICE|IC|EC|RJ|RJX|NJ|TGV|THA|EN/.test(products)) hasFernverkehr = true;
    });
    if (hasSBahn && !hasFernverkehr) {
      displayType = 5;
      displayName = 'DB S-Bahn';
      description = 'Optimiert für S-Bahn Anzeige';
    }
  }

  // Zeilenanzahl bestimmen: Anzahl der verschiedenen Linien/Richtungen
  let totalDirections = 0;
  stations.forEach(s => {
    if (s.directions && s.directions.length > 0) {
      // Neue Struktur: directions Array zaehlen
      totalDirections += s.directions.length;
    } else if (s.filter) {
      // Fallback: Filter-Linien zaehlen (alte Struktur)
      totalDirections += s.filter.split(',').length;
    } else {
      totalDirections += 1;
    }
  });
  // Zeilen = Anzahl Richtungen, aber max 3
  let rows;
  if (totalDirections > 3) {
    rows = 3;
  } else if (totalDirections < 1) {
    rows = 1;
  } else {
    rows = totalDirections;
  }

  // Gehweg-Werte (alle auf 0 als Default)
  const gehwegValues = stations.map(() => 0);

  // Einzigartige Stationen für stationDetails (gruppiert nach Name+Netzwerk)
  const uniqueStationDetails = [];
  const seenStations = new Set();
  stations.forEach(s => {
    const key = `${s.network}:${s.stopName}`;
    if (!seenStations.has(key)) {
      seenStations.add(key);
      uniqueStationDetails.push({
        id: s.stopId,
        name: s.stopName,
        network: s.network,
        lines: s.filter ? s.filter.split(',').map(l => ({ name: l, direction: '' })) : []
      });
    }
  });

  return {
    // Station-Daten
    rbl: stations.map(s => s.fullId).join(','),
    filter: stations.map(s => s.filter || '').join('|'),
    stationDetails: uniqueStationDetails,

    // Display-Einstellungen
    colour: displayType,
    colourName: displayName,
    description: description,
    rows: rows,
    sortMode: 1,           // Statisch als Default
    displayLight: 3,       // Hell

    // Barrierefreiheit (nur wenn vom Netzwerk unterstützt)
    chopper: capabilities.showHighFloor ? 1 : 0,
    silberpfeil: capabilities.showAirCondition ? 1 : 0,

    // Nachtmodus (aus als Default)
    nightMode: false,
    nightStart: 22,
    nightEnd: 7,

    // Erweiterte Einstellungen
    displayMode: 1,        // Gemischt
    stopInterval: 10,
    gehweg: gehwegValues,
    showFunMessages: true,
    sortMode: 1,           // 1 = Zeit (dynamisch), 2 = Statisch
    rowOrder: '',          // Zeilen-Reihenfolge einfach (für Wien)
    rowOrderDestination: '',  // Zeilen-Reihenfolge mit Ziel (für Linz)

    // Linien-Gruppierung (Format: "1+62,U1+U2" bedeutet Gruppe1=1&62, Gruppe2=U1&U2)
    lineGroups: stations.map(s => s.lineGroups || '').join('|'),

    // Linien+Ziel Filter für Linz (automatisch aus ausgewählten directions)
    // Format: "1:Auwiesen,2:Universität" - wird automatisch aus den directions gebaut
    lineFilterDestination: buildLineFilterDestination(stations),

    // Capabilities (für UI)
    capabilities: capabilities,
    dominantNetwork: dominantNetwork
  };
}

/**
 * Baut den lineFilterDestination String aus den directions der Linz-Stationen
 *
 * NEUES FORMAT mit Richtungs-Gruppierung:
 * "1:Auwiesen|Remise Kleinmünchen,2:Universität|Auhof"
 *
 * Bedeutung: Linie 1 zeigt Auwiesen UND Remise Kleinmünchen (gleiche Richtung),
 *            Linie 2 zeigt Universität UND Auhof
 *
 * Das löst das Problem, dass abends Trams als "Remise" statt "Auwiesen" fahren,
 * aber trotzdem angezeigt werden sollen.
 */
function buildLineFilterDestination(stationsList) {
  // Gruppiere nach Linie: { "1": ["Auwiesen", "Remise Kleinmünchen"], "2": ["Universität"] }
  const lineToDestinations = {};

  stationsList.forEach(station => {
    // Nur für Linz (Netzwerke ohne richtungsId)
    if (station.network === 'LINZ' && station.directions && station.directions.length > 0) {
      station.directions.forEach(dir => {
        if (dir.line && dir.towards) {
          const line = dir.line;
          const dest = dir.towards;

          if (!lineToDestinations[line]) {
            lineToDestinations[line] = [];
          }
          if (!lineToDestinations[line].includes(dest)) {
            lineToDestinations[line].push(dest);
          }
        }
      });
    }
  });

  // Baue Filter-String: "1:Auwiesen|Remise,2:Uni|Auhof"
  const filters = [];
  for (const line in lineToDestinations) {
    const destinations = lineToDestinations[line];
    // Mehrere Ziele mit | verbinden
    filters.push(line + ':' + destinations.join('|'));
  }

  return filters.join(',');
}

function goToDisplayConfig() {
  if (stations.length === 0) return;

  // Speichere vorherige Einstellungen (vom Gerät geladen)
  const previousSettings = recommendedConfig ? {
    lineGroups: recommendedConfig.lineGroups,
    sortMode: recommendedConfig.sortMode,
    rowOrder: recommendedConfig.rowOrder,
    rowOrderDestination: recommendedConfig.rowOrderDestination,
    lineFilterDestination: recommendedConfig.lineFilterDestination,
    gehweg: recommendedConfig.gehweg,
    rows: recommendedConfig.rows,
    colour: recommendedConfig.colour,
    displayLight: recommendedConfig.displayLight,
    chopper: recommendedConfig.chopper,
    silberpfeil: recommendedConfig.silberpfeil,
    nightMode: recommendedConfig.nightMode,
    nightStart: recommendedConfig.nightStart,
    nightEnd: recommendedConfig.nightEnd,
    showFunMessages: recommendedConfig.showFunMessages
  } : null;

  // Berechne vollständige empfohlene Konfiguration
  recommendedConfig = calculateRecommendedConfig();
  if (!recommendedConfig) return;

  // Übernehme vorherige Einstellungen (wenn vom Gerät geladen)
  if (previousSettings) {
    if (previousSettings.lineGroups) recommendedConfig.lineGroups = previousSettings.lineGroups;
    if (previousSettings.sortMode !== undefined) recommendedConfig.sortMode = previousSettings.sortMode;
    if (previousSettings.rowOrder) recommendedConfig.rowOrder = previousSettings.rowOrder;
    if (previousSettings.rowOrderDestination) recommendedConfig.rowOrderDestination = previousSettings.rowOrderDestination;
    if (previousSettings.lineFilterDestination) recommendedConfig.lineFilterDestination = previousSettings.lineFilterDestination;
    if (previousSettings.gehweg) recommendedConfig.gehweg = previousSettings.gehweg;
    if (previousSettings.rows) recommendedConfig.rows = previousSettings.rows;
    if (previousSettings.colour !== undefined) recommendedConfig.colour = previousSettings.colour;
    if (previousSettings.displayLight !== undefined) recommendedConfig.displayLight = previousSettings.displayLight;
    if (previousSettings.chopper !== undefined) recommendedConfig.chopper = previousSettings.chopper;
    if (previousSettings.silberpfeil !== undefined) recommendedConfig.silberpfeil = previousSettings.silberpfeil;
    if (previousSettings.nightMode !== undefined) recommendedConfig.nightMode = previousSettings.nightMode;
    if (previousSettings.nightStart !== undefined) recommendedConfig.nightStart = previousSettings.nightStart;
    if (previousSettings.nightEnd !== undefined) recommendedConfig.nightEnd = previousSettings.nightEnd;
    if (previousSettings.showFunMessages !== undefined) recommendedConfig.showFunMessages = previousSettings.showFunMessages;
  }

  suggestedColor = recommendedConfig.colour;
  suggestedRows = recommendedConfig.rows;

  // Update UI
  document.getElementById('suggestedColorName').textContent = recommendedConfig.colourName;
  document.getElementById('suggestedRows').textContent = recommendedConfig.rows + ' Zeile' + (recommendedConfig.rows > 1 ? 'n' : '');
  document.getElementById('previewTitle').textContent = recommendedConfig.colourName + ' Ansicht';
  document.getElementById('previewDesc').textContent = recommendedConfig.description;

  // Update selects
  document.getElementById('colorSelect').value = recommendedConfig.colour;
  document.getElementById('rowsSelect').value = recommendedConfig.rows;

  // Update realistische Preview
  updateRealisticPreview(recommendedConfig);

  // Feintuning ausblenden
  document.getElementById('finetuningSection').classList.add('hidden');

  // Quick Preview initialisieren
  initializeQuickPreview();

  // Show config step, hide others
  document.getElementById('stationsCard').classList.add('hidden');
  document.getElementById('stepDisplayConfig').classList.remove('hidden');
  document.querySelector('.bottom-bar').style.display = 'none';
}

function suggestDisplayConfig() {
  // Count networks
  const networkCounts = {};
  stations.forEach(s => {
    networkCounts[s.network] = (networkCounts[s.network] || 0) + 1;
  });
  
  // Find dominant network
  const dominantNetwork = Object.entries(networkCounts)
    .sort((a, b) => b[1] - a[1])[0][0];
  
  // Determine color
  let colorId, colorName, description;
  
  if (dominantNetwork === 'DB') {
    // Check for S-Bahn vs Fernverkehr
    const dbStations = stations.filter(s => s.network === 'DB');
    let hasSBahn = false;
    let hasFernverkehr = false;
    
    dbStations.forEach(s => {
      const products = s.filter || s.products || '';
      if (products.includes('S')) hasSBahn = true;
      if (/ICE|IC|EC|RJ|RJX|NJ|TGV|THA|EN/.test(products)) hasFernverkehr = true;
    });
    
    if (hasFernverkehr && !hasSBahn) {
      colorId = 6;
      colorName = 'DB Fernverkehr';
      description = 'Optimiert für ICE, IC, RJ Anzeige';
    } else if (hasSBahn && !hasFernverkehr) {
      colorId = 5;
      colorName = 'DB S-Bahn';
      description = 'Optimiert für S-Bahn Anzeige';
    } else {
      colorId = 6;
      colorName = 'DB Fernverkehr';
      description = 'Gemischte DB-Verbindungen';
    }
  } else {
    const netColor = NETWORK_COLORS[dominantNetwork] || NETWORK_COLORS.WL;
    colorId = netColor.id;
    colorName = netColor.name;
    description = `Optimiert für ${NETWORKS[dominantNetwork]?.name || dominantNetwork}`;
  }
  
  // Count total lines
  let totalLines = 0;
  stations.forEach(s => {
    if (s.filter) {
      totalLines += s.filter.split(',').length;
    } else {
      totalLines += 2; // Default assumption
    }
  });
  
  // Suggest rows (max 4, min 1)
  let rows = Math.min(Math.max(Math.ceil(totalLines / stations.length), 1), 4);
  if (totalLines <= 2) rows = totalLines;
  if (rows > 4) rows = 4;
  
  return { color: colorId, colorName, rows, description };
}

// ==================== REALISTISCHE DISPLAY-VORSCHAU ====================
// Basierend auf display_wien.cpp - echtes Wiener Linien Design
function updateRealisticPreview(config) {
  const previewEl = document.getElementById('previewImage');
  const colour = config.colour;
  const rows = config.rows;

  // Farben basierend auf Display-Typ (wie in display_wien.cpp / display_factory.h)
  const displayStyles = {
    1: { // Wiener Linien
      bg: '#000500',           // Fast schwarz (rgb(0,5,0))
      text: '#fff05d',         // Wiener Linien Gelb (rgb(255,240,93))
      highlight: '#87ceeb',    // Skyblue für Hochflurer
      name: 'Wiener Linien'
    },
    2: { // Linz AG - LED Matrix Style
      bg: '#001405',           // Dunkelgrün (LED Matrix Hintergrund)
      text: '#c8ff00',         // Gelb-Grün (LED Farbe)
      highlight: '#c8ff00',
      name: 'Linz AG',
      isLedMatrix: true        // Flag für spezielles LED-Matrix Rendering
    },
    3: { // VBB Berlin
      bg: '#000500',
      text: '#fff05d',
      highlight: '#87ceeb',
      name: 'VBB Berlin'
    },
    4: { // WLB Badner Bahn
      bg: '#1E4D8C',
      text: '#ffffff',
      highlight: '#ffffff',
      name: 'WLB'
    },
    5: { // DB S-Bahn
      bg: '#1a1a2e',
      text: '#00ff00',
      highlight: '#ffffff',
      name: 'DB S-Bahn'
    },
    6: { // DB Fernverkehr
      bg: '#1a1a2e',
      text: '#ffffff',
      highlight: '#EC0016',
      name: 'DB Fernverkehr'
    },
    7: { // BODO
      bg: '#005BBB',
      text: '#ffffff',
      highlight: '#ffffff',
      name: 'BODO'
    },
    8: { // Salzburg AG
      bg: '#1a1a1a',
      text: '#ffffff',
      highlight: '#E3000F',
      name: 'Salzburg AG'
    }
  };

  const style = displayStyles[colour] || displayStyles[1];

  // Echte Daten aus stations extrahieren
  let sampleData = [];
  let timeCounter = 3;
  if (stations.length > 0) {
    stations.forEach(s => {
      if (s.filter) {
        const lines = s.filter.split(',');
        lines.forEach(lineName => {
          if (sampleData.length < rows) {
            const line = lineName.trim();
            // Hochflurer-Erkennung für Wien (Straßenbahnen ohne ULF)
            const isHochflurer = s.network === 'WL' && !line.startsWith('U') && /^\d+$/.test(line);
            sampleData.push({
              line: line,
              dest: s.stopName.length > 15 ? s.stopName.substring(0, 14) + '.' : s.stopName,
              time: timeCounter,
              isHighfloor: isHochflurer
            });
            timeCounter += 3;
          }
        });
      }
    });
  }

  // Fallback Beispieldaten
  if (sampleData.length === 0) {
    const fallbackData = {
      1: [{ line: 'U6', dest: 'Floridsdorf', time: 3 }, { line: '2', dest: 'Ottakring', time: 6 }, { line: '13A', dest: 'Hauptbahnhof', time: 8 }],
      2: [{ line: '1', dest: 'Auwiesen', time: 2 }, { line: '2', dest: 'Solar City', time: 5 }, { line: '43', dest: 'Harbachsiedlung', time: 8 }],  // Linz AG
      4: [{ line: 'WLB', dest: 'Baden Josefsplatz', time: 4 }, { line: 'WLB', dest: 'Wien Oper', time: 12 }],
      5: [{ line: 'S1', dest: 'Oranienburg', time: 2 }, { line: 'S7', dest: 'Ahrensfelde', time: 5 }],
      6: [{ line: 'ICE', dest: 'Berlin Hbf', time: 12 }, { line: 'RJ', dest: 'Wien Hbf', time: 28 }],
      7: [{ line: '7', dest: 'Ravensburg', time: 4 }, { line: '1', dest: 'Friedrichshafen', time: 9 }],
      8: [{ line: '1', dest: 'Hellbrunn', time: 3 }, { line: 'S3', dest: 'Salzburg Hbf', time: 7 }, { line: '22', dest: 'Aigen', time: 11 }]
    };
    sampleData = (fallbackData[colour] || fallbackData[1]).slice(0, rows);
  }

  // Realistische Preview im Stil von display_wien.cpp / display_linz.cpp
  const rowHeight = Math.floor(80 / rows);
  previewEl.style.borderRadius = '4px';
  previewEl.style.padding = '0';
  previewEl.style.overflow = 'hidden';

  // Linz AG LED-Matrix Style
  if (style.isLedMatrix) {
    const gridColor = '#000a02';  // Noch dunkleres Grün für Gitter
    previewEl.style.background = style.bg;
    previewEl.style.backgroundImage = `radial-gradient(circle, ${gridColor} 1px, transparent 1px)`;
    previewEl.style.backgroundSize = '4px 4px';

    previewEl.innerHTML = `
      <div class="realistic-display linz-led-matrix" style="width:100%;height:100%;display:flex;flex-direction:column;">
        ${sampleData.slice(0, rows).map((dep, i) => {
          return `
            <div class="display-row" style="
              flex:1;
              display:flex;
              align-items:center;
              padding:2px 4px;
              border-bottom:${i < rows - 1 ? '1px solid #000a02' : 'none'};
              color:${style.text};
              font-family:'Courier New',monospace;
              text-shadow: 0 0 4px ${style.text}, 0 0 8px ${style.text}40;
            ">
              <span style="font-weight:bold;font-size:10px;min-width:28px;text-shadow:0 0 6px ${style.text};">${dep.line}</span>
              <span style="flex:1;font-size:8px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 4px;">${dep.dest}</span>
              <span style="font-weight:bold;font-size:11px;text-shadow:0 0 6px ${style.text};">${dep.time}</span>
            </div>
          `;
        }).join('')}
      </div>
    `;
  } else {
    // Standard Display Style (Wien, etc.)
    previewEl.style.background = style.bg;
    previewEl.style.backgroundImage = 'none';

    previewEl.innerHTML = `
      <div class="realistic-display" style="width:100%;height:100%;display:flex;flex-direction:column;">
        ${sampleData.slice(0, rows).map((dep, i) => {
          const textColor = dep.isHighfloor && config.capabilities?.showHighFloor ? style.highlight : style.text;
          return `
            <div class="display-row" style="
              flex:1;
              display:flex;
              align-items:center;
              padding:2px 4px;
              border-bottom:${i < rows - 1 ? '1px solid #000' : 'none'};
              color:${textColor};
              font-family:'Courier New',monospace;
            ">
              <span style="font-weight:bold;font-size:10px;min-width:28px;">${dep.line}</span>
              <span style="flex:1;font-size:8px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 4px;">${dep.dest}</span>
              <span style="font-weight:bold;font-size:11px;color:${style.text};">${dep.time}</span>
            </div>
          `;
        }).join('')}
      </div>
    `;
  }
}

// Legacy-Funktion für Kompatibilität
function updatePreviewAnimation(suggestion) {
  updateRealisticPreview({
    colour: suggestion.color,
    rows: suggestion.rows,
    capabilities: CITY_CAPABILITIES[stations[0]?.network] || CITY_CAPABILITIES.WL
  });
}

function backFromDisplayConfig() {
  document.getElementById('stepDisplayConfig').classList.add('hidden');
  document.getElementById('stationsCard').classList.remove('hidden');
  document.querySelector('.bottom-bar').style.display = 'block';
}

function showFinetuning() {
  const section = document.getElementById('finetuningSection');
  section.classList.toggle('hidden');

  if (!section.classList.contains('hidden')) {
    // Initialisiere Feintuning-Bereich
    updateWienOptionsVisibility();
    populateGehwegQuickList();
  }
}

// ==================== QUICK PREVIEW & SETTINGS ====================
function updateQuickPreview() {
  if (!recommendedConfig) return;

  const settingsList = document.getElementById('settingsList');
  const colorSelect = document.getElementById('colorSelect');
  const rowsSelect = document.getElementById('rowsSelect');

  const colour = parseInt(colorSelect.value);
  const rows = parseInt(rowsSelect.value);

  // Update recommendedConfig mit neuen Werten
  recommendedConfig.colour = colour;
  recommendedConfig.rows = rows;

  // Finde das passende Netzwerk für die Capabilities
  let networkForCapabilities = recommendedConfig.dominantNetwork;
  if (colour === 1) networkForCapabilities = 'WL';
  else if (colour === 2) networkForCapabilities = 'LINZ';
  else if (colour === 4) networkForCapabilities = 'WLB';
  else if (colour === 5 || colour === 6) networkForCapabilities = 'DB';
  else if (colour === 3) networkForCapabilities = 'BERLIN';
  else if (colour === 7) networkForCapabilities = 'BODO';

  const caps = CITY_CAPABILITIES[networkForCapabilities] || CITY_CAPABILITIES.WL;

  // Settings Tags aktualisieren
  const colorNames = {1:'Wiener Linien',2:'Linz AG',3:'VBB Berlin',4:'WLB',5:'DB S-Bahn',6:'DB Fernverkehr',7:'BODO'};
  settingsList.innerHTML = `
    <span class="setting-tag">${colorNames[colour] || 'Standard'}</span>
    <span class="setting-tag">${rows} Zeile${rows > 1 ? 'n' : ''}</span>
    <span class="setting-tag ${caps.showHighFloor ? 'highlight' : 'inactive'}">Hochflurer ${caps.showHighFloor ? '✓' : '✗'}</span>
    <span class="setting-tag ${caps.showAirCondition ? 'highlight' : 'inactive'}">Klimaanlage ${caps.showAirCondition ? '✓' : '✗'}</span>
    <span class="setting-tag highlight">Gehweg ✓</span>
    <span class="setting-tag highlight">Nachtmodus ✓</span>
  `;

  // Wien-Optionen anzeigen/verstecken
  updateWienOptionsVisibility();

  // Preview aktualisieren
  updateRealisticPreview(recommendedConfig);
}

function updateWienOptionsVisibility() {
  const wienOptions = document.getElementById('wienOptions');
  const colorSelect = document.getElementById('colorSelect');
  if (!wienOptions || !colorSelect) return;

  const colour = parseInt(colorSelect.value);

  // Wien-Optionen nur für Wiener Linien (1) und Linz (2) anzeigen
  // da diese die gleiche Optik nutzen
  const showWienOptions = (colour === 1);

  wienOptions.style.display = showWienOptions ? 'block' : 'none';
}

function populateGehwegQuickList() {
  const container = document.getElementById('gehwegQuickList');
  if (!container || !recommendedConfig) return;

  if (recommendedConfig.stationDetails.length === 0) {
    container.innerHTML = '<p style="color:#888;font-size:12px;">Keine Stationen</p>';
    return;
  }

  container.innerHTML = recommendedConfig.stationDetails.map((station, i) => {
    const value = recommendedConfig.gehweg[i] || 0;
    return `
      <div class="gehweg-quick-item">
        <span class="station-name">${station.name}</span>
        <input type="number" min="0" max="15" value="${value}"
               onchange="updateGehwegValue(${i}, this.value)">
        <span class="unit">Min</span>
      </div>
    `;
  }).join('');
}

function updateGehwegValue(index, value) {
  if (!recommendedConfig) return;
  const val = Math.max(0, Math.min(15, parseInt(value) || 0));
  recommendedConfig.gehweg[index] = val;
}

function applyQuickSettings() {
  if (!recommendedConfig) return;

  // Werte aus den Selects übernehmen
  recommendedConfig.colour = parseInt(document.getElementById('colorSelect').value);
  recommendedConfig.rows = parseInt(document.getElementById('rowsSelect').value);

  // Wien-spezifische Optionen
  const chopperSelect = document.getElementById('chopperSelect');
  const silberpfeilSelect = document.getElementById('silberpfeilSelect');
  if (chopperSelect) recommendedConfig.chopper = parseInt(chopperSelect.value);
  if (silberpfeilSelect) recommendedConfig.silberpfeil = parseInt(silberpfeilSelect.value);

  // Speichern
  showSavingOverlay('Speichere Einstellungen...');
  sendConfigToDeviceDirect(recommendedConfig);
}

// Initial Quick Preview erstellen wenn Config vorhanden
function initializeQuickPreview() {
  if (!recommendedConfig) return;

  const settingsList = document.getElementById('settingsList');
  if (!settingsList) return;

  const caps = recommendedConfig.capabilities || {};
  const colorNames = {1:'Wiener Linien',2:'Linz AG',3:'VBB Berlin',4:'WLB',5:'DB S-Bahn',6:'DB Fernverkehr',7:'BODO'};

  settingsList.innerHTML = `
    <span class="setting-tag">${colorNames[recommendedConfig.colour] || 'Standard'}</span>
    <span class="setting-tag">${recommendedConfig.rows} Zeile${recommendedConfig.rows > 1 ? 'n' : ''}</span>
    <span class="setting-tag ${caps.showHighFloor ? 'highlight' : 'inactive'}">Hochflurer ${caps.showHighFloor ? '✓' : '✗'}</span>
    <span class="setting-tag ${caps.showAirCondition ? 'highlight' : 'inactive'}">Klimaanlage ${caps.showAirCondition ? '✓' : '✗'}</span>
    <span class="setting-tag highlight">Gehweg ✓</span>
    <span class="setting-tag highlight">Nachtmodus ✓</span>
  `;
}

// ==================== JA PASST - DIREKT SPEICHERN ====================
function sendWithSuggestion() {
  if (!recommendedConfig) {
    alert('Fehler: Keine Konfiguration berechnet');
    return;
  }

  // Zeige Lade-Animation
  showSavingOverlay('Speichere Einstellungen...');

  // Direkt an das Gerät senden (via postMessage an Parent)
  sendConfigToDeviceDirect(recommendedConfig);
}

// ==================== FEINTUNING - INTEGRIERT IN CITIES.HTML ====================
function goToFinetuning() {
  if (!recommendedConfig) return;

  // Verstecke Display-Config, zeige Finetuning
  document.getElementById('stepDisplayConfig').classList.add('hidden');
  document.getElementById('stepFinetuning').classList.remove('hidden');

  // Initialisiere Finetuning-Felder mit aktueller Config
  initFinetuningStep();
}

async function initFinetuningStep() {
  const config = recommendedConfig;
  if (!config) return;

  // Display-Typ
  document.getElementById('ftColorSelect').value = config.colour;

  // Zeilen-Toggle setzen
  setFtRows(config.rows || 2);

  // Helligkeit-Toggle setzen
  setFtBrightness(config.displayLight || 3);

  // Wien-spezifische Optionen
  const caps = config.capabilities || {};
  const wienOptions = document.getElementById('ftWienOptions');
  if (caps.showHighFloor || caps.showAirCondition) {
    wienOptions.style.display = 'block';
    setFtToggle('ftChopperToggle', config.chopper === 1);
    setFtToggle('ftSilberpfeilToggle', config.silberpfeil === 1);
  } else {
    wienOptions.style.display = 'none';
  }

  // Nachtmodus
  setFtToggle('ftNightModeToggle', config.nightMode);
  document.getElementById('ftNightStart').value = config.nightStart || 22;
  document.getElementById('ftNightEnd').value = config.nightEnd || 6;
  updateNightTimeVisibility();

  // Fun Messages
  setFtToggle('ftFunMessagesToggle', config.showFunMessages);

  // Gehweg-Liste
  populateFtGehwegList();

  // Gruppierung initialisieren (lädt auch roworderdestination und setzt ftLineGroups)
  // WICHTIG: await weil initFtGrouping async ist!
  await initFtGrouping();

  // Sortierungsmodus initialisieren (NACH initFtGrouping!)
  setFtSortMode(config.sortMode || 1);

  // Preview aktualisieren
  updateFinetuningPreview();
}

function setFtToggle(id, active) {
  const el = document.getElementById(id);
  if (el) {
    if (active) {
      el.classList.add('active');
    } else {
      el.classList.remove('active');
    }
  }
}

function toggleFtSwitch(id) {
  const el = document.getElementById(id);
  if (el) {
    el.classList.toggle('active');
  }
}

function isFtToggleActive(id) {
  const el = document.getElementById(id);
  return el && el.classList.contains('active');
}

function updateNightTimeVisibility() {
  const nightRow = document.getElementById('ftNightTimesRow');
  const isNightMode = isFtToggleActive('ftNightModeToggle');
  nightRow.style.display = isNightMode ? 'flex' : 'none';
}

function populateFtGehwegList() {
  const container = document.getElementById('ftGehwegList');
  container.innerHTML = '';

  // Gruppiere Stationen nach Name und Netzwerk (wie in updateStationsList)
  const uniqueStations = new Map();
  stations.forEach((station, index) => {
    const key = `${station.network}:${station.stopName}`;
    if (!uniqueStations.has(key)) {
      uniqueStations.set(key, { station, index });
    }
  });

  uniqueStations.forEach(({ station, index }) => {
    const gehwegValue = recommendedConfig.gehweg?.[index] || 0;
    const item = document.createElement('div');
    item.className = 'gehweg-item';
    item.innerHTML = `
      <span class="station-name">${station.stopName}</span>
      <input type="number" min="0" max="30" value="${gehwegValue}"
             id="ftGehweg_${index}" onchange="updateFinetuningPreview()">
      <span class="unit">Min</span>
    `;
    container.appendChild(item);
  });
}

// Toggle-Buttons für Zeilen
function setFtRows(value) {
  document.querySelectorAll('#ftRowsToggle .toggle-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.value) === value);
  });
  updateFinetuningPreview();
}

function getFtRows() {
  const active = document.querySelector('#ftRowsToggle .toggle-btn.active');
  return active ? parseInt(active.dataset.value) : 2;
}

// Toggle-Buttons für Helligkeit
function setFtBrightness(value) {
  document.querySelectorAll('#ftBrightnessToggle .toggle-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.value) === value);
  });
}

function getFtBrightness() {
  const active = document.querySelector('#ftBrightnessToggle .toggle-btn.active');
  return active ? parseInt(active.dataset.value) : 3;
}

// ==================== SORTIERUNG & ZEILEN-REIHENFOLGE ====================
let ftSortMode = 1;  // 1 = Zeit (dynamisch), 2 = Statisch
// NEUES KONZEPT: ftLineGroups IST die Reihenfolge (ftRowOrder wird nicht mehr benötigt)
// Die Reihenfolge von ftLineGroups entspricht der Anzeigereihenfolge auf dem Display

function setFtSortMode(value) {
  ftSortMode = value;
  document.querySelectorAll('#ftSortModeToggle .toggle-btn').forEach(btn => {
    btn.classList.toggle('active', parseInt(btn.dataset.value) === value);
  });

  // Info-Box umschalten
  const infoTime = document.getElementById('ftSortModeInfoTime');
  const infoStatic = document.getElementById('ftSortModeInfoStatic');
  if (infoTime && infoStatic) {
    infoTime.style.display = (value === 1) ? 'block' : 'none';
    infoStatic.style.display = (value === 2) ? 'block' : 'none';
  }

  // Zeilen-Reihenfolge Sektion ein-/ausblenden
  const rowOrderSection = document.getElementById('ftRowOrderSection');
  if (value === 2) {
    rowOrderSection.style.display = 'block';
    initRowOrderList();
  } else {
    rowOrderSection.style.display = 'none';
  }
}

function getFtSortMode() {
  return ftSortMode;
}

function initRowOrderList() {
  // NEUES KONZEPT: ftLineGroups IST die Reihenfolge
  // Diese Funktion wird aufgerufen wenn der statische Sortiermodus aktiviert wird
  // ftLineGroups sollte bereits durch initFtGrouping() befüllt sein

  // Falls ftLineGroups noch leer ist, aus ftAllDirections befüllen
  if (ftLineGroups.length === 0 && ftAllDirections.length > 0) {
    ftAllDirections.forEach(dir => {
      ftLineGroups.push({ directions: [dir.key] });
    });
    ftPoolDirections = [];
  }

  renderRowOrderList();
}

function renderRowOrderList() {
  const container = document.getElementById('ftRowOrderList');

  // NEUES KONZEPT: ftLineGroups IST die Reihenfolge (alle Einträge sind Gruppen)
  if (ftLineGroups.length === 0) {
    container.innerHTML = '<div class="ft-row-order-empty">Keine Linien verfügbar</div>';
    return;
  }

  container.innerHTML = ftLineGroups.map((group, idx) => {
    const directions = group.directions || [];
    const isMulti = directions.length > 1;  // Echte Gruppe (mehr als 1 Richtung)

    // Badges für alle Richtungen der Gruppe
    const badgesHtml = directions.map(key => {
      const dirInfo = ftAllDirections.find(d => d.key === key);
      const line = dirInfo ? dirInfo.line : key.split(':')[0];
      const type = dirInfo ? dirInfo.type : '';
      const badgeClass = getLineTypeClass(type, line);
      return `<span class="line-badge ${badgeClass}">${line}</span>`;
    }).join('');

    // Zieltext aus der ersten Richtung
    const firstKey = directions[0];
    const firstDirInfo = ftAllDirections.find(d => d.key === firstKey);
    const destText = firstDirInfo ? (firstDirInfo.towards || 'Alle Richtungen') : '';

    const cssClass = isMulti ? 'ft-row-order-item ft-row-order-group' : 'ft-row-order-item';

    return `
      <div class="${cssClass}" draggable="true" data-index="${idx}">
        <span class="drag-handle">☰</span>
        <span class="row-number">${idx + 1}</span>
        <span class="group-badges">${badgesHtml}</span>
        <span class="direction-text">${destText}</span>
      </div>
    `;
  }).join('');

  // Drag & Drop Events hinzufügen
  const items = container.querySelectorAll('.ft-row-order-item');
  items.forEach(item => {
    item.addEventListener('dragstart', handleDragStart);
    item.addEventListener('dragend', handleDragEnd);
    item.addEventListener('dragover', handleDragOver);
    item.addEventListener('drop', handleDrop);
    item.addEventListener('dragenter', handleDragEnter);
    item.addEventListener('dragleave', handleDragLeave);
  });
}

let draggedItem = null;
let draggedIndex = -1;

function handleDragStart(e) {
  draggedItem = this;
  draggedIndex = parseInt(this.dataset.index);
  this.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', draggedIndex);
}

function handleDragEnd(e) {
  this.classList.remove('dragging');
  document.querySelectorAll('.ft-row-order-item').forEach(item => {
    item.classList.remove('drag-over');
  });
  draggedItem = null;
  draggedIndex = -1;
}

function handleDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
}

function handleDragEnter(e) {
  e.preventDefault();
  if (this !== draggedItem) {
    this.classList.add('drag-over');
  }
}

function handleDragLeave(e) {
  this.classList.remove('drag-over');
}

function handleDrop(e) {
  e.preventDefault();
  e.stopPropagation();

  const targetIndex = parseInt(this.dataset.index);

  if (draggedIndex !== -1 && draggedIndex !== targetIndex) {
    // NEUES KONZEPT: ftLineGroups ist jetzt die Reihenfolge
    const movedItem = ftLineGroups.splice(draggedIndex, 1)[0];
    ftLineGroups.splice(targetIndex, 0, movedItem);

    // Liste neu rendern
    renderRowOrderList();
  }

  this.classList.remove('drag-over');
}

function getRowOrderString() {
  // NEUES KONZEPT: ftLineGroups ist die Reihenfolge
  // Einfaches Format für Wien: "U6,2,43" - nur Linien
  const lines = [];
  ftLineGroups.forEach(group => {
    if (group.directions && group.directions.length > 0) {
      // Alle Linien der Gruppe hinzufügen
      group.directions.forEach(key => {
        const dirInfo = ftAllDirections.find(d => d.key === key);
        const line = dirInfo ? dirInfo.line : key.split(':')[0];
        if (!lines.includes(line)) {
          lines.push(line);
        }
      });
    }
  });
  return lines.join(',');
}

function getRowOrderDestinationString() {
  // NEUES KONZEPT: Alles sind Gruppen (auch 1er-Gruppen)
  // Format: "1:Uni+2:Uni,3:Solarc,26:St.Margarethen" - Gruppen mit +, Einträge mit ,
  // ftLineGroups = [{ directions: ['1:RId1', '2:RId2'] }, { directions: ['3:RId3'] }, ...]

  if (ftLineGroups.length === 0) {
    return '';
  }

  const items = [];
  ftLineGroups.forEach(group => {
    if (group.directions && group.directions.length > 0) {
      // Jede Richtung (Key) in "Linie:Ziel" Format umwandeln
      const groupParts = group.directions.map(key => {
        const dirInfo = ftAllDirections.find(d => d.key === key);
        if (dirInfo) {
          return `${dirInfo.line}:${dirInfo.towards || ''}`;
        }
        // Fallback: Key direkt verwenden (ohne das R-Prefix falls vorhanden)
        const colonIdx = key.indexOf(':');
        if (colonIdx > 0) {
          const line = key.substring(0, colonIdx);
          let dest = key.substring(colonIdx + 1);
          // Falls es ein richtungsId-Key ist (z.B. "2:R60500123"), leeren String verwenden
          if (dest.startsWith('R') && /^\d+$/.test(dest.substring(1))) {
            dest = '';
          }
          return `${line}:${dest}`;
        }
        return key;
      });
      items.push(groupParts.join('+'));
    }
  });
  return items.join(',');
}

function updateFinetuningPreview() {
  const colour = parseInt(document.getElementById('ftColorSelect').value);
  const rows = getFtRows();
  const previewEl = document.getElementById('finetuningPreview');

  // Echte Daten aus stations extrahieren
  let data = [];
  let timeCounter = 3;

  // Durch alle Stationen gehen und Linien sammeln
  stations.forEach(station => {
    if (station.filter) {
      const lines = station.filter.split(',').map(l => l.trim());
      lines.forEach(lineName => {
        // Hochflurer-Erkennung für Wien (Niederflur: ULF-Linien)
        const isHochflurer = station.network === 'WL' && !lineName.startsWith('U') && /^\d+$/.test(lineName);
        data.push({
          line: lineName,
          dest: station.stopName,
          time: timeCounter,
          timeStr: `${String(14 + Math.floor(timeCounter / 60)).padStart(2, '0')}:${String(20 + (timeCounter % 60)).padStart(2, '0')}`,
          hf: isHochflurer
        });
        timeCounter += Math.floor(Math.random() * 4) + 2;
      });
    }
  });

  // Fallback wenn keine Daten vorhanden
  if (data.length === 0) {
    const fallbackData = {
      1: [{ line: 'U6', dest: 'Floridsdorf', time: 3, hf: false }, { line: '2', dest: 'Ottakring', time: 6, hf: true }, { line: '13A', dest: 'Hauptbahnhof', time: 8, hf: false }],
      2: [{ line: '1', dest: 'Auwiesen', time: 4 }, { line: '3', dest: 'Landgutstr.', time: 7 }, { line: '46', dest: 'Hauptbahnhof', time: 11 }],
      3: [{ line: 'U6', dest: 'Alt-Tegel', time: 2 }, { line: 'S1', dest: 'Oranienburg', time: 5 }, { line: 'M10', dest: 'Warschauer', time: 8 }],
      4: [{ line: 'WLB', dest: 'Baden Josefsplatz', time: 4 }, { line: 'WLB', dest: 'Wien Oper', time: 12 }, { line: 'WLB', dest: 'Baden', time: 19 }],
      5: [{ line: 'S1', dest: 'Oranienburg', time: 2 }, { line: 'S7', dest: 'Ahrensfelde', time: 5 }, { line: 'S5', dest: 'Strausberg', time: 9 }],
      6: [{ line: 'ICE', dest: 'Berlin Hbf', time: 12 }, { line: 'RJ', dest: 'Wien Hbf', time: 28 }, { line: 'IC', dest: 'Hamburg', time: 45 }],
      7: [{ line: '7', dest: 'Ravensburg', time: 4 }, { line: '1', dest: 'Friedrichshafen', time: 9 }, { line: '4', dest: 'Konstanz', time: 15 }],
      8: [{ line: '1', dest: 'Hellbrunn', time: 3, timeStr: '14:23' }, { line: 'S3', dest: 'Golling', time: 7, timeStr: '14:27' }, { line: '22', dest: 'Aigen', time: 11, timeStr: '14:31' }]
    };
    data = fallbackData[colour] || fallbackData[1];
  }

  data = data.slice(0, rows);

  // Render basierend auf Display-Typ
  let html = '';

  if (colour === 2) {
    // LINZ Style: Gelb-Grün auf dunkelgrünem Hintergrund mit LED-Matrix Look
    const bgColor = '#001405';  // Sehr dunkelgrün
    const textColor = '#c8ff00';  // Gelb-Grün (LED-Farbe)
    const gridColor = '#002810';  // Etwas heller für Gitter-Muster
    previewEl.style.background = bgColor;
    previewEl.style.backgroundImage = `radial-gradient(circle, ${gridColor} 1px, transparent 1px)`;
    previewEl.style.backgroundSize = '4px 4px';

    html = `<div style="width:100%;height:100%;display:flex;flex-direction:column;font-family:'Courier New',monospace;">
      ${data.map((dep, i) => {
        return `<div style="flex:1;display:flex;align-items:center;padding:4px 8px;border-bottom:${i < rows - 1 ? '1px solid #0a3020' : 'none'};color:${textColor};">
          <span style="font-weight:bold;font-size:18px;min-width:36px;text-shadow:0 0 8px ${textColor};">${dep.line}</span>
          <span style="flex:1;font-size:11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 6px;text-shadow:0 0 4px ${textColor};">${dep.dest}</span>
          <span style="font-weight:bold;font-size:18px;text-shadow:0 0 8px ${textColor};">${dep.time}</span>
        </div>`;
      }).join('')}
    </div>`;
  }
  else if (colour === 1 || colour === 3) {
    // Wien/VBB Style: Gelb auf schwarz
    const bgColor = '#000500';
    const textColor = '#fff05d';
    const hlColor = '#87ceeb';
    previewEl.style.background = bgColor;
    previewEl.style.backgroundImage = 'none';

    html = `<div style="width:100%;height:100%;display:flex;flex-direction:column;font-family:'Courier New',monospace;">
      ${data.map((dep, i) => {
        const color = dep.hf ? hlColor : textColor;
        return `<div style="flex:1;display:flex;align-items:center;padding:4px 10px;border-bottom:${i < rows - 1 ? '2px solid #000' : 'none'};color:${color};">
          <span style="font-weight:bold;font-size:16px;min-width:44px;">${dep.line}</span>
          <span style="flex:1;font-size:12px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 8px;">${dep.dest}</span>
          <span style="font-weight:bold;font-size:18px;">${dep.time}</span>
        </div>`;
      }).join('')}
    </div>`;
  }
  else if (colour === 4) {
    // WLB Style: Weiß auf blau gestreift
    previewEl.style.background = '#0078c8';
    previewEl.style.backgroundImage = 'none';

    html = `<div style="width:100%;height:100%;display:flex;flex-direction:column;font-family:Arial,sans-serif;">
      ${data.map((dep, i) => {
        const bg = i % 2 === 0 ? '#0078c8' : '#003278';
        return `<div style="flex:1;display:flex;align-items:center;padding:4px 10px;background:${bg};color:#fff;">
          <span style="font-weight:bold;font-size:14px;min-width:44px;background:${bg};padding:2px 4px;border-radius:3px;">WLB</span>
          <span style="flex:1;font-size:11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 8px;">${dep.dest}</span>
          <span style="font-weight:bold;font-size:16px;">${dep.time}</span>
        </div>`;
      }).join('')}
    </div>`;
  }
  else if (colour === 5 || colour === 6) {
    // DB Style: Modern dunkel
    const bgColor = '#0a1628';
    previewEl.style.background = bgColor;
    previewEl.style.backgroundImage = 'none';

    html = `<div style="width:100%;height:100%;display:flex;flex-direction:column;font-family:Arial,sans-serif;">
      ${data.map((dep, i) => {
        const rowBg = i % 2 === 0 ? '#192846' : '#0f1c32';
        const lineColor = dep.line.startsWith('S') ? '#009640' : (dep.line === 'ICE' || dep.line === 'IC' ? '#c80000' : (dep.line === 'RJ' ? '#c80000' : '#666'));
        return `<div style="flex:1;display:flex;align-items:center;padding:4px 8px;background:${rowBg};color:#fff;">
          <span style="font-weight:bold;font-size:12px;min-width:38px;background:${lineColor};color:#fff;padding:3px 6px;border-radius:4px;text-align:center;">${dep.line}</span>
          <span style="flex:1;font-size:11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 8px;">${dep.dest}</span>
          <span style="font-weight:bold;font-size:14px;color:#fff;">${dep.time}</span>
        </div>`;
      }).join('')}
    </div>`;
  }
  else if (colour === 7) {
    // BODO Style: Blau
    previewEl.style.background = '#005BBB';
    previewEl.style.backgroundImage = 'none';

    html = `<div style="width:100%;height:100%;display:flex;flex-direction:column;font-family:Arial,sans-serif;">
      ${data.map((dep, i) => `<div style="flex:1;display:flex;align-items:center;padding:4px 10px;color:#fff;">
          <span style="font-weight:bold;font-size:14px;min-width:36px;">${dep.line}</span>
          <span style="flex:1;font-size:11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 8px;">${dep.dest}</span>
          <span style="font-weight:bold;font-size:16px;">${dep.time}</span>
        </div>`).join('')}
    </div>`;
  }
  else if (colour === 8) {
    // Salzburg Style: Schwarz/Weiß alternierend mit Uhrzeit
    previewEl.style.background = '#000';
    previewEl.style.backgroundImage = 'none';

    html = `<div style="width:100%;height:100%;display:flex;flex-direction:column;font-family:Arial,sans-serif;">
      ${data.map((dep, i) => {
        const bg = i % 2 === 0 ? '#000' : '#fff';
        const text = i % 2 === 0 ? '#fff' : '#000';
        const timeDisplay = dep.timeStr || `${String(14 + Math.floor(dep.time / 60)).padStart(2, '0')}:${String(20 + dep.time).padStart(2, '0')}`;
        return `<div style="flex:1;display:flex;align-items:center;padding:4px 10px;background:${bg};color:${text};">
          <span style="font-weight:bold;font-size:14px;min-width:32px;">${dep.line}</span>
          <span style="flex:1;font-size:11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 8px;">${dep.dest}</span>
          <span style="font-weight:bold;font-size:14px;">${timeDisplay}</span>
        </div>`;
      }).join('')}
    </div>`;
  }

  previewEl.innerHTML = html;

  // Wien-Optionen ein/ausblenden basierend auf Display-Typ
  const wienOptions = document.getElementById('ftWienOptions');
  if (colour === 1) {
    wienOptions.style.display = 'block';
  } else {
    wienOptions.style.display = 'none';
  }
}

function backFromFinetuning() {
  document.getElementById('stepFinetuning').classList.add('hidden');
  document.getElementById('stepDisplayConfig').classList.remove('hidden');
}

// ==================== FEINTUNING: LINZ LINIEN-FILTER ====================
// Filter wird jetzt automatisch aus ausgewählten Linien generiert (in buildLineFilterDestination)

function isLinzNetwork() {
  // Prüfe ob mindestens eine Station aus Linz ist
  return stations.some(s => s.network === 'LINZ' || (s.stopId && s.stopId.toString().startsWith('LINZ:')));
}

function collectFtLineFilter() {
  // Generiere Filter aus allen aktuell verfügbaren Richtungen
  // Format: "1:Universität,2:Solarcity,27:Chemiepark"
  // WICHTIG: Gruppierte Linien werden im Display sowieso nicht gefiltert,
  // daher hier nur die ungruppierten Richtungen sammeln

  const filterParts = [];

  // Sammle alle Keys die in Gruppen sind
  const groupedKeys = new Set();
  for (const group of ftLineGroups) {
    if (group.directions) {
      for (const key of group.directions) {
        groupedKeys.add(key);
      }
    }
  }

  // Nur ungroupierte Richtungen zum Filter hinzufügen
  for (const dir of ftAllDirections) {
    if (dir.line && dir.towards && !groupedKeys.has(dir.key)) {
      filterParts.push(dir.line + ':' + dir.towards);
    }
  }

  // Entferne Duplikate
  const uniqueParts = [...new Set(filterParts)];
  return uniqueParts.join(',');
}

// ==================== FEINTUNING: RICHTUNGS-GRUPPIERUNG ====================
// NEUES KONZEPT: Alles sind Gruppen - auch einzelne Linien (1er-Gruppen)
// ftLineGroups = Alle Zeilen-Einträge in Reihenfolge (= roworderdestination)
// ftPoolDirections = Verfügbare Richtungen zum Hinzufügen (nicht in Gruppen)
let ftLineGroups = [];  // Array of groups: [{ directions: ['key1', 'key2'] }, { directions: ['key3'] }, ...]
let ftAllDirections = [];  // Alle verfügbaren Richtungen aus den Stationen (Master-Liste)
let ftPoolDirections = [];  // Richtungen die noch nicht in ftLineGroups sind (zum Hinzufügen)
let ftGroupingMode = false;  // true wenn gerade eine Gruppe erstellt wird
let ftSelectedForGroup = [];  // Ausgewaehlte Richtungen fuer neue Gruppe
let ftEventsAttached = false;  // Flag ob Events schon angehaengt wurden

async function initFtGrouping() {
  ftLineGroups = [];
  ftAllDirections = [];
  ftPoolDirections = [];
  ftGroupingMode = false;
  ftSelectedForGroup = [];

  // Richtungen aus allen Stationen laden
  await loadFtDirectionsFromStations();

  // Bestehende Gruppierung aus roworderdestination laden (neues Format)
  // Fallback auf linegroups für alte Configs
  if (recommendedConfig && recommendedConfig.rowOrderDestination) {
    parseRowOrderDestination(recommendedConfig.rowOrderDestination);
  } else if (recommendedConfig && recommendedConfig.lineGroups) {
    parseFtExistingGroups(recommendedConfig.lineGroups);
  }

  // WICHTIG: Prüfe ob alle Richtungen in ftAllDirections auch in ftLineGroups sind
  // Falls nicht: Füge fehlende Richtungen als neue 1er-Gruppen hinzu
  const usedKeys = new Set();
  ftLineGroups.forEach(group => {
    (group.directions || []).forEach(key => usedKeys.add(key));
  });

  // Fehlende Richtungen finden und hinzufügen
  const missingDirections = ftAllDirections.filter(d => !usedKeys.has(d.key));
  if (missingDirections.length > 0) {
    missingDirections.forEach(dir => {
      ftLineGroups.push({ directions: [dir.key] });
    });
  }

  // Ungültige Keys aus ftLineGroups entfernen (Keys die nicht mehr in ftAllDirections existieren)
  const validKeys = new Set(ftAllDirections.map(d => d.key));
  ftLineGroups = ftLineGroups.map(group => {
    const validDirections = (group.directions || []).filter(key => validKeys.has(key));
    return { directions: validDirections };
  }).filter(group => group.directions.length > 0);  // Leere Gruppen entfernen

  // Pool aktualisieren (Richtungen die nicht in Gruppen sind)
  updatePoolDirections();

  // Wenn immer noch keine Gruppen existieren, erstelle für jede Richtung eine 1er-Gruppe
  if (ftLineGroups.length === 0 && ftAllDirections.length > 0) {
    ftAllDirections.forEach(dir => {
      ftLineGroups.push({ directions: [dir.key] });
    });
    ftPoolDirections = [];
  }

  // Event-Listener anhaengen (nur einmal)
  if (!ftEventsAttached) {
    setupFtGroupingEvents();
    ftEventsAttached = true;
  }

  // UI rendern
  renderFtGroupingUI();
}

// Parse roworderdestination: "26:St. Margarethen,2:Uni+1:Uni,2:solarCity+1:Auwiesen"
function parseRowOrderDestination(rowOrderStr) {
  if (!rowOrderStr) return;

  ftLineGroups = [];

  // Split by , für Einträge, dann by + für Gruppen-Mitglieder
  const entries = rowOrderStr.split(',').map(s => s.trim()).filter(s => s);

  entries.forEach(entry => {
    const parts = entry.split('+').map(p => p.trim()).filter(p => p);
    const directions = [];

    parts.forEach(part => {
      // part ist "2:Universität" oder "2:R60500123"
      const key = mapToAvailableKey(part);
      if (key) {
        directions.push(key);
      }
    });

    if (directions.length > 0) {
      ftLineGroups.push({ directions });
    }
  });
}

// Mappt einen gespeicherten Key (z.B. "2:Universität") auf den verfügbaren Key in ftAllDirections
function mapToAvailableKey(savedKey) {
  // Exakter Match
  let match = ftAllDirections.find(d => d.key === savedKey);
  if (match) return match.key;

  // Parse savedKey
  const colonIdx = savedKey.indexOf(':');
  if (colonIdx <= 0) return null;

  const line = savedKey.substring(0, colonIdx);
  const rest = savedKey.substring(colonIdx + 1);

  // Ist es ein richtungsId-Key? (z.B. "2:R60500123")
  if (rest.startsWith('R')) {
    const richtungsId = rest.substring(1);
    match = ftAllDirections.find(d => d.line === line && d.richtungsId === richtungsId);
    if (match) return match.key;
  }

  // Ist es ein Zieltext-Key? (z.B. "2:Universität")
  match = ftAllDirections.find(d => d.line === line && d.towards === rest);
  if (match) return match.key;

  // Partial Match auf Zieltext
  match = ftAllDirections.find(d =>
    d.line === line && (d.towards.includes(rest) || rest.includes(d.towards))
  );
  if (match) return match.key;

  // Nur Linie matchen als letzter Fallback
  match = ftAllDirections.find(d => d.line === line);
  if (match) return match.key;

  return null;
}

// Aktualisiert ftPoolDirections basierend auf ftLineGroups
function updatePoolDirections() {
  const usedKeys = new Set();
  ftLineGroups.forEach(group => {
    (group.directions || []).forEach(key => usedKeys.add(key));
  });

  ftPoolDirections = ftAllDirections.filter(d => !usedKeys.has(d.key));
}

async function loadFtDirectionsFromStations() {
  ftAllDirections = [];

  // Richtungen aus den gespeicherten Stationen laden
  for (const station of stations) {
    if (station.directions && Array.isArray(station.directions)) {
      station.directions.forEach(dir => {
        const lineName = dir.line || '';
        const towards = dir.towards || '';
        const type = dir.type || '';
        const richtungsId = dir.richtungsId || '';

        if (!lineName) return;

        // Bei BODO: Nur erlaubte Linien
        if (station.network === 'BODO') {
          const trimmed = lineName.trim();
          const isAllowed = /^[\d\/]+$/.test(trimmed) ||
            (trimmed.match(/^S\s*(\d+)$/i) && parseInt(trimmed.match(/^S\s*(\d+)$/i)[1]) >= 20 && parseInt(trimmed.match(/^S\s*(\d+)$/i)[1]) <= 199) ||
            (trimmed.match(/^R\s*(\d+)$/i) && parseInt(trimmed.match(/^R\s*(\d+)$/i)[1]) >= 25 && parseInt(trimmed.match(/^R\s*(\d+)$/i)[1]) <= 199);
          if (!isAllowed) return;
        }

        const key = richtungsId ? `${lineName}:R${richtungsId}` : `${lineName}:${towards}`;
        if (!ftAllDirections.some(d => d.key === key)) {
          ftAllDirections.push({
            key, line: lineName, towards, type, richtungsId,
            station: station.stopName, network: station.network
          });
        }
      });
    }
  }

  // Richtungen ohne towards entfernen wenn es welche mit towards gibt
  const linesWithTowards = new Set();
  ftAllDirections.forEach(d => { if (d.towards) linesWithTowards.add(d.line); });
  ftAllDirections = ftAllDirections.filter(d => !(!d.towards && linesWithTowards.has(d.line)));

  // Nach Linie und dann nach Richtung sortieren
  ftAllDirections.sort((a, b) => {
    const aNum = parseInt(a.line) || 999;
    const bNum = parseInt(b.line) || 999;
    if (aNum !== bNum) return aNum - bNum;
    if (a.line !== b.line) return a.line.localeCompare(b.line);
    return (a.towards || '').localeCompare(b.towards || '');
  });
}

function parseFtExistingGroups(lineGroupsStr) {
  if (!lineGroupsStr) return;

  ftLineGroups = [];

  // Format: "U1:Leopoldau+62:Meidling,1:xyz+2:abc" (alt) oder "12:R60500312+19:R60500097" (neu)
  const groups = lineGroupsStr.split(',');
  groups.forEach((groupStr) => {
    if (groupStr.includes('+')) {
      const rawDirections = groupStr.split('+').map(d => d.trim()).filter(d => d);

      // Mappe alte Keys (12:Auwiesen) auf neue Keys (12:R60500312)
      const mappedDirections = rawDirections.map(rawKey => {
        // Wenn der Key schon das neue Format hat (mit :R), behalte ihn
        if (rawKey.includes(':R')) {
          return rawKey;
        }

        // Altes Format: "12:Auwiesen" -> versuche passende richtungsId zu finden
        const colonIdx = rawKey.indexOf(':');
        if (colonIdx > 0) {
          const line = rawKey.substring(0, colonIdx);
          const dest = rawKey.substring(colonIdx + 1);

          // Suche in ftAllDirections nach passender Linie+Richtung
          const match = ftAllDirections.find(d =>
            d.line === line && d.towards === dest
          );

          if (match) {
            return match.key;  // Nutze den neuen Key mit richtungsId
          }

          // Kein exakter Match - versuche nur nach Linie zu matchen
          const lineMatch = ftAllDirections.find(d => d.line === line);
          if (lineMatch && lineMatch.richtungsId) {
            // Warnung: Nicht exakt, aber besser als nichts
            return lineMatch.key;
          }
        }

        // Fallback: Behalte den alten Key
        return rawKey;
      });

      if (mappedDirections.length >= 2) {
        ftLineGroups.push({ directions: mappedDirections });
      }
    }
  });
}

function renderFtGroupingUI() {
  renderFtGroups();
  renderFtPool();
}

function renderFtGroups() {
  const container = document.getElementById('ftGroupsContainer');
  if (!container) return;

  // Nur echte Gruppen (mit >= 2 Richtungen) anzeigen
  let html = '';
  let groupNumber = 1;

  ftLineGroups.forEach((group, gIdx) => {
    const directions = group.directions || [];

    // Nur echte Gruppen (2+) als "Gruppen" darstellen
    if (directions.length >= 2) {
      const directionsHtml = directions.map((key, dIdx) => {
        const dirInfo = ftAllDirections.find(d => d.key === key);
        const lineName = dirInfo ? dirInfo.line : key.split(':')[0];
        const towards = dirInfo ? dirInfo.towards : key.split(':').slice(1).join(':');
        const badgeClass = dirInfo ? getLineTypeClass(dirInfo.type, lineName) : 'type-default';

        return `
          <div class="ft-direction-chip" data-group-idx="${gIdx}" data-dir-idx="${dIdx}" data-action="remove-from-group">
            <span class="line-badge ${badgeClass}">${lineName}</span>
            ${towards ? `<span class="dir-dest">${towards}</span>` : ''}
            <span class="chip-remove">x</span>
          </div>
        `;
      }).join('');

      html += `
        <div class="ft-group-box" data-group-idx="${gIdx}">
          <div class="ft-group-header">
            <span>Gruppe ${groupNumber}</span>
            <button class="ft-group-delete" data-action="delete-group" data-group-idx="${gIdx}">Loeschen</button>
          </div>
          <div class="ft-group-content">${directionsHtml}</div>
        </div>
      `;
      groupNumber++;
    }
  });

  // Wenn im Gruppierungs-Modus: aktuelle Auswahl anzeigen
  if (ftGroupingMode) {
    const selectedHtml = ftSelectedForGroup.map((key, idx) => {
      const dirInfo = ftAllDirections.find(d => d.key === key);
      const lineName = dirInfo ? dirInfo.line : key.split(':')[0];
      const towards = dirInfo ? dirInfo.towards : key.split(':').slice(1).join(':');
      const badgeClass = dirInfo ? getLineTypeClass(dirInfo.type, lineName) : 'type-default';

      return `
        <div class="ft-direction-chip selected" data-selection-idx="${idx}" data-action="toggle-selection">
          <span class="line-badge ${badgeClass}">${lineName}</span>
          ${towards ? `<span class="dir-dest">${towards}</span>` : ''}
        </div>
      `;
    }).join('');

    html += `
      <div class="ft-group-box ft-group-creating">
        <div class="ft-group-header">
          <span>Neue Gruppe (${ftSelectedForGroup.length} ausgewaehlt)</span>
        </div>
        <div class="ft-group-content">
          ${selectedHtml || '<span class="hint">Waehle mindestens 2 Richtungen aus dem Pool</span>'}
        </div>
        <div class="ft-group-actions">
          <button class="btn-cancel" data-action="cancel-grouping">Abbrechen</button>
          <button class="btn-confirm" data-action="confirm-group" ${ftSelectedForGroup.length < 2 ? 'disabled' : ''}>Gruppe erstellen</button>
        </div>
      </div>
    `;
  } else {
    // Button zum Erstellen einer neuen Gruppe (nur wenn es genug 1er-Gruppen gibt)
    const singleGroups = ftLineGroups.filter(g => (g.directions || []).length === 1);
    if (singleGroups.length >= 2) {
      html += `
        <button class="ft-create-group-btn" data-action="start-grouping">+ Neue Gruppe erstellen</button>
      `;
    }
  }

  container.innerHTML = html;
}

function renderFtPool() {
  const container = document.getElementById('ftPoolItems');
  if (!container) return;

  // NEUES KONZEPT: Pool = 1er-Gruppen aus ftLineGroups (einzelne Linien die nicht in echten Gruppen sind)
  // Filtere: 1er-Gruppen die nicht in der aktuellen Auswahl sind
  const singleGroups = ftLineGroups.filter(g => {
    const dirs = g.directions || [];
    return dirs.length === 1 && !ftSelectedForGroup.includes(dirs[0]);
  });

  if (singleGroups.length === 0 && !ftGroupingMode) {
    container.innerHTML = '<div class="pool-empty">Alle Richtungen sind gruppiert</div>';
    return;
  }

  if (singleGroups.length === 0 && ftGroupingMode) {
    container.innerHTML = '<div class="pool-empty">Keine weiteren Richtungen verfuegbar</div>';
    return;
  }

  container.innerHTML = singleGroups.map((group, idx) => {
    const key = group.directions[0];
    const dirInfo = ftAllDirections.find(d => d.key === key);
    const line = dirInfo ? dirInfo.line : key.split(':')[0];
    const towards = dirInfo ? dirInfo.towards : '';
    const type = dirInfo ? dirInfo.type : '';
    const badgeClass = getLineTypeClass(type, line);
    const poolIdx = ftAllDirections.findIndex(d => d.key === key);

    // Immer klickbar - Gruppierungsmodus startet automatisch beim ersten Klick
    return `
      <div class="ft-direction-chip clickable" data-pool-idx="${poolIdx}">
        <span class="line-badge ${badgeClass}">${line}</span>
        ${towards ? `<span class="dir-dest">${towards}</span>` : ''}
      </div>
    `;
  }).join('');
}

// Touch-freundliche Gruppierungs-Funktionen
function startFtGrouping() {
  ftGroupingMode = true;
  ftSelectedForGroup = [];
  renderFtGroupingUI();
}

function cancelFtGrouping() {
  ftGroupingMode = false;
  ftSelectedForGroup = [];
  renderFtGroupingUI();
}

function toggleFtSelection(key) {
  const idx = ftSelectedForGroup.indexOf(key);
  if (idx === -1) {
    ftSelectedForGroup.push(key);
  } else {
    ftSelectedForGroup.splice(idx, 1);
  }
  renderFtGroupingUI();
}

function confirmFtGroup() {
  if (ftSelectedForGroup.length < 2) {
    return;
  }

  // Entferne die ausgewählten Richtungen aus bestehenden Gruppen
  // (z.B. wenn sie vorher als 1er-Gruppen existierten)
  ftSelectedForGroup.forEach(key => {
    // Finde Gruppen, die diesen Key enthalten
    for (let i = ftLineGroups.length - 1; i >= 0; i--) {
      const group = ftLineGroups[i];
      const keyIdx = (group.directions || []).indexOf(key);
      if (keyIdx !== -1) {
        // Entferne den Key aus dieser Gruppe
        group.directions.splice(keyIdx, 1);
        // Entferne leere Gruppen
        if (group.directions.length === 0) {
          ftLineGroups.splice(i, 1);
        }
      }
    }
  });

  // Neue Gruppe erstellen
  ftLineGroups.push({ directions: [...ftSelectedForGroup] });

  // Pool aktualisieren
  updatePoolDirections();

  // Reset
  ftGroupingMode = false;
  ftSelectedForGroup = [];
  renderFtGroupingUI();

  // Reihenfolge-Liste aktualisieren (Gruppen haben sich geändert)
  updateRowOrderAfterGroupChange();
}

function deleteFtGroup(gIdx) {
  // Alle Richtungen der Gruppe als eigene 1er-Gruppen wieder einfügen
  const groupToDelete = ftLineGroups[gIdx];
  if (groupToDelete && groupToDelete.directions) {
    groupToDelete.directions.forEach(key => {
      ftLineGroups.push({ directions: [key] });
    });
  }

  // Gruppe entfernen
  ftLineGroups.splice(gIdx, 1);

  // Pool aktualisieren
  updatePoolDirections();

  renderFtGroupingUI();

  // Reihenfolge-Liste aktualisieren (Gruppen haben sich geändert)
  updateRowOrderAfterGroupChange();
}

function removeFromGroup(gIdx, key) {
  if (ftLineGroups[gIdx] && ftLineGroups[gIdx].directions) {
    ftLineGroups[gIdx].directions = ftLineGroups[gIdx].directions.filter(d => d !== key);

    // Wenn Gruppe noch mindestens 2 Richtungen hat, bleibt sie bestehen
    // Die entfernte Richtung wird als neue 1er-Gruppe hinzugefügt
    if (ftLineGroups[gIdx].directions.length >= 2) {
      // Entfernte Richtung als eigene 1er-Gruppe hinzufügen
      ftLineGroups.push({ directions: [key] });
    } else if (ftLineGroups[gIdx].directions.length === 1) {
      // Nur noch 1 Richtung übrig - Gruppe bleibt als 1er-Gruppe
      // Entfernte Richtung als eigene 1er-Gruppe hinzufügen
      ftLineGroups.push({ directions: [key] });
    } else {
      // Gruppe ist leer - entfernen
      ftLineGroups.splice(gIdx, 1);
      // Entfernte Richtung als eigene 1er-Gruppe hinzufügen
      ftLineGroups.push({ directions: [key] });
    }
  }

  // Pool aktualisieren
  updatePoolDirections();

  renderFtGroupingUI();

  // Reihenfolge-Liste aktualisieren (Gruppen haben sich geändert)
  updateRowOrderAfterGroupChange();
}

// Aktualisiere die Reihenfolge-Liste wenn Gruppen geändert werden
function updateRowOrderAfterGroupChange() {
  // NEUES KONZEPT: ftLineGroups IST die Reihenfolge
  // Bei Gruppenänderung: einfach die Liste neu rendern
  if (ftSortMode === 2) {
    renderRowOrderList();
  }
}


function collectFtLineGroups() {
  // linegroups Format: "2:R60500312+1:R60500920,19:R60500097+12:R60500123"
  // Nur echte Gruppen (≥2 Richtungen) für ESP32 linegroups
  if (ftLineGroups.length === 0) {
    return '';
  }

  // Nur Gruppen mit mindestens 2 Richtungen
  const validGroups = ftLineGroups.filter(g => g.directions && g.directions.length >= 2);

  if (validGroups.length === 0) {
    return '';
  }

  // Keys zu "Linie:RrichtungsId" Format (für ESP32 Matching)
  return validGroups.map(g => {
    return g.directions.map(key => {
      const dirInfo = ftAllDirections.find(d => d.key === key);
      if (dirInfo && dirInfo.richtungsId) {
        return `${dirInfo.line}:R${dirInfo.richtungsId}`;
      }
      return key;  // Fallback: Key direkt verwenden
    }).join('+');
  }).join(',');
}

function shortenDestFt(dest) {
  if (!dest) return '';
  if (dest.length > 18) return dest.substring(0, 16) + '...';
  return dest;
}

function escapeHtmlFt(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Event Delegation fuer Gruppierung - vermeidet Probleme mit Sonderzeichen
function setupFtGroupingEvents() {
  // Groups Container Events
  const groupsContainer = document.getElementById('ftGroupsContainer');

  if (groupsContainer) {
    groupsContainer.addEventListener('click', function(e) {
      const target = e.target.closest('[data-action]');
      if (!target) return;

      const action = target.dataset.action;

      switch(action) {
        case 'start-grouping':
          startFtGrouping();
          break;
        case 'cancel-grouping':
          cancelFtGrouping();
          break;
        case 'confirm-group':
          if (!target.disabled) {
            confirmFtGroup();
          }
          break;
        case 'delete-group':
          const gIdx = parseInt(target.dataset.groupIdx);
          deleteFtGroup(gIdx);
          break;
        case 'remove-from-group':
          const groupIdx = parseInt(target.dataset.groupIdx);
          const dirIdx = parseInt(target.dataset.dirIdx);
          if (ftLineGroups[groupIdx] && ftLineGroups[groupIdx].directions) {
            ftLineGroups[groupIdx].directions.splice(dirIdx, 1);
            if (ftLineGroups[groupIdx].directions.length < 2) {
              ftLineGroups.splice(groupIdx, 1);
            }
            renderFtGroupingUI();
          }
          break;
        case 'toggle-selection':
          const selIdx = parseInt(target.dataset.selectionIdx);
          if (selIdx >= 0 && selIdx < ftSelectedForGroup.length) {
            ftSelectedForGroup.splice(selIdx, 1);
            renderFtGroupingUI();
          }
          break;
      }
    });
  }

  // Pool Container Events
  const poolContainer = document.getElementById('ftPoolItems');

  if (poolContainer) {
    poolContainer.addEventListener('click', function(e) {
      const target = e.target.closest('[data-pool-idx]');
      if (!target) return;

      const poolIdx = parseInt(target.dataset.poolIdx);

      if (poolIdx >= 0 && poolIdx < ftAllDirections.length) {
        const key = ftAllDirections[poolIdx].key;

        // Automatisch Gruppierungsmodus starten wenn noch nicht aktiv
        if (!ftGroupingMode) {
          ftGroupingMode = true;
          ftSelectedForGroup = [];
        }

        toggleFtSelection(key);
      }
    });
  }
}

// Event-Listener werden in initFtGrouping() angehaengt

function saveFromFinetuning() {
  // Sammle alle Finetuning-Werte
  const colour = parseInt(document.getElementById('ftColorSelect').value);
  const rows = getFtRows();
  const displayLight = getFtBrightness();
  const chopper = isFtToggleActive('ftChopperToggle') ? 1 : 0;
  const silberpfeil = isFtToggleActive('ftSilberpfeilToggle') ? 1 : 0;
  const nightMode = isFtToggleActive('ftNightModeToggle');
  const nightStart = parseInt(document.getElementById('ftNightStart').value) || 22;
  const nightEnd = parseInt(document.getElementById('ftNightEnd').value) || 6;
  const showFunMessages = isFtToggleActive('ftFunMessagesToggle');
  const sortMode = getFtSortMode();
  const rowOrder = getRowOrderString();  // Einfach für Wien
  const rowOrderDestination = getRowOrderDestinationString();  // Mit Ziel für Linz

  // Gehweg-Werte sammeln
  const gehweg = [];
  stations.forEach((_, index) => {
    const input = document.getElementById(`ftGehweg_${index}`);
    gehweg.push(input ? parseInt(input.value) || 0 : 0);
  });

  // Linien-Gruppierung sammeln
  const lineGroupsStr = collectFtLineGroups();

  // Linz Linien+Ziel Filter sammeln (linefilterdestination)
  const lineFilterDestStr = collectFtLineFilter();

  // Update recommendedConfig
  recommendedConfig.colour = colour;
  recommendedConfig.rows = rows;
  recommendedConfig.displayLight = displayLight;
  recommendedConfig.chopper = chopper;
  recommendedConfig.silberpfeil = silberpfeil;
  recommendedConfig.nightMode = nightMode;
  recommendedConfig.nightStart = nightStart;
  recommendedConfig.nightEnd = nightEnd;
  recommendedConfig.showFunMessages = showFunMessages;
  recommendedConfig.gehweg = gehweg;
  recommendedConfig.lineGroups = lineGroupsStr;
  recommendedConfig.lineFilterDestination = lineFilterDestStr;  // Linz Linie+Ziel Filter
  recommendedConfig.sortMode = sortMode;
  recommendedConfig.rowOrder = rowOrder;
  recommendedConfig.rowOrderDestination = rowOrderDestination;

  // Speichern
  showSavingOverlay('Speichere Einstellungen...');
  sendConfigToDeviceDirect(recommendedConfig);
}

// Legacy-Funktion - jetzt zu Feintuning umgeleitet
function sendWithCustomConfig() {
  goToFinetuning();
}

// ==================== DIREKT AN GERÄT SENDEN ====================
let saveRetryCount = 0;
const MAX_SAVE_RETRIES = 3;

function sendConfigToDeviceDirect(config) {
  // Baue die Gehweg-String im neuen Format: "stopId:value|stopId:value"
  let gehwegString = '0';
  if (config.stationDetails && config.gehweg) {
    const entries = [];
    config.stationDetails.forEach((station, i) => {
      const value = config.gehweg[i] || 0;
      const stopId = station.id || '';
      if (stopId) {
        entries.push(`${stopId}:${value}`);
      }
    });
    if (entries.length > 0) {
      gehwegString = entries.join('|');
    }
  }

  // Config-Daten für ESP32
  const configData = {
    type: 'setRBL',
    rbl: config.rbl,
    filter: config.filter,
    zeilen: String(config.rows),
    sortmode: String(config.sortMode),
    chopper: String(config.chopper),
    silberpfeil: String(config.silberpfeil),
    colour: String(config.colour),
    displaylight: String(config.displayLight),
    nightmode: config.nightMode ? '1' : '0',
    nightstart: String(config.nightStart),
    nightend: String(config.nightEnd),
    showfunmessages: config.showFunMessages ? '1' : '0',
    displaymode: String(config.displayMode),
    stopinterval: String(config.stopInterval),
    gehweg: gehwegString,
    linegroups: config.lineGroups || '',  // NEU: Linien-Gruppierung
    linefilter: config.lineFilter || '',  // Linien-Filter (nur Linienname)
    linefilterdestination: config.lineFilterDestination || '',  // NEU: Linien+Ziel Filter für Linz
    roworder: config.rowOrder || '',  // NEU: Zeilen-Reihenfolge einfach
    roworderdestination: config.rowOrderDestination || ''  // NEU: Zeilen-Reihenfolge mit Ziel
  };

  // Prüfe ob wir im iframe sind
  const inIframe = window.parent && window.parent !== window;

  if (inIframe) {
    // Sende an Parent (ESP32-Seite)
    window.parent.postMessage(configData, '*');

    // Timeout für Erfolgs-Feedback
    const saveTimeout = setTimeout(() => {
      // Falls nach 10 Sekunden keine Antwort, zeige Fehler
      if (saveRetryCount < MAX_SAVE_RETRIES) {
        saveRetryCount++;
        updateSavingOverlay(`Verbindung prüfen... (Versuch ${saveRetryCount}/${MAX_SAVE_RETRIES})`);
        // Retry nach 2 Sekunden
        setTimeout(() => {
          window.parent.postMessage(configData, '*');
        }, 2000);
      } else {
        showSaveError();
      }
    }, 10000);

    // Status-Updates
    setTimeout(() => {
      updateSavingOverlay('Neustart läuft...');
    }, 2000);

    setTimeout(() => {
      updateSavingOverlay('Fertig! Dein Straba startet neu...');
      clearTimeout(saveTimeout);
      saveRetryCount = 0;
    }, 5000);

  } else {
    // Nicht im iframe - versuche direkt an straba.local zu senden
    sendConfigDirectToDevice(configData, config);
  }
}

// Direkte Kommunikation mit straba.local (Fallback wenn nicht im iframe)
async function sendConfigDirectToDevice(configData, originalConfig) {
  updateSavingOverlay('Verbinde mit straba.local...');

  try {
    // Versuche zuerst zu prüfen ob straba.local erreichbar ist
    const checkResponse = await fetch('http://straba.local/', {
      method: 'HEAD',
      mode: 'no-cors',
      cache: 'no-store'
    }).catch(() => null);

    // Baue FormData für POST
    const formData = new URLSearchParams();
    formData.append('stop-id', configData.rbl);
    formData.append('filter', configData.filter);
    formData.append('anzeige', configData.zeilen);
    formData.append('sortmode', configData.sortmode);
    formData.append('chopper', configData.chopper);
    formData.append('silberpfeil', configData.silberpfeil);
    formData.append('colour', configData.colour);
    formData.append('displaylight', configData.displaylight);
    formData.append('nightmode', configData.nightmode);
    formData.append('nightstart', configData.nightstart);
    formData.append('nightend', configData.nightend);
    formData.append('showfunmessages', configData.showfunmessages);
    formData.append('displaymode', configData.displaymode);
    formData.append('stopinterval', configData.stopinterval);
    formData.append('gehweg', configData.gehweg);
    formData.append('linegroups', configData.linegroups);
    formData.append('linefilter', configData.linefilter);
    formData.append('linefilterdestination', configData.linefilterdestination);

    updateSavingOverlay('Speichere Einstellungen...');

    const response = await fetch('http://straba.local/config', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: formData.toString()
    });

    if (response.ok) {
      updateSavingOverlay('Fertig! Dein Straba startet neu...');
      setTimeout(() => {
        hideSavingOverlay();
        showSuccessMessage();
      }, 3000);
    } else {
      throw new Error(`HTTP ${response.status}`);
    }

  } catch (error) {
    console.error('Direktes Senden fehlgeschlagen:', error);
    showSaveError();
  }
}

// ==================== FEHLERBEHANDLUNG ====================
function showSaveError() {
  hideSavingOverlay();

  const errorOverlay = document.createElement('div');
  errorOverlay.id = 'errorOverlay';
  errorOverlay.innerHTML = `
    <div class="error-content">
      <div class="error-icon">⚠️</div>
      <h3>Verbindung fehlgeschlagen</h3>
      <p>straba.local ist nicht erreichbar.</p>
      <ul class="error-tips">
        <li>Stelle sicher, dass dein Straba eingeschaltet ist</li>
        <li>Prüfe, ob du mit dem Straba-WLAN verbunden bist</li>
        <li>Versuche die Seite neu zu laden</li>
      </ul>
      <div class="error-actions">
        <button class="btn btn-primary" onclick="retrySave()">Erneut versuchen</button>
        <button class="btn btn-secondary" onclick="goToFinetuningFromError()">Feintuning öffnen</button>
      </div>
    </div>
  `;
  errorOverlay.style.cssText = `
    position:fixed;top:0;left:0;right:0;bottom:0;
    background:rgba(0,0,0,0.95);display:flex;
    align-items:center;justify-content:center;z-index:9999;
    padding:20px;
  `;

  const style = document.createElement('style');
  style.textContent = `
    .error-content{background:#fff;border-radius:16px;padding:30px;max-width:400px;text-align:center;}
    .error-icon{font-size:48px;margin-bottom:15px;}
    .error-content h3{color:#d32f2f;margin-bottom:10px;}
    .error-content p{color:#666;margin-bottom:15px;}
    .error-tips{text-align:left;color:#666;font-size:13px;margin:15px 0;padding-left:20px;}
    .error-tips li{margin-bottom:8px;}
    .error-actions{display:flex;flex-direction:column;gap:10px;margin-top:20px;}
    .error-actions .btn{width:100%;}
  `;
  document.head.appendChild(style);
  document.body.appendChild(errorOverlay);
}

function retrySave() {
  const errorOverlay = document.getElementById('errorOverlay');
  if (errorOverlay) errorOverlay.remove();

  saveRetryCount = 0;
  showSavingOverlay('Erneuter Versuch...');
  sendConfigToDeviceDirect(recommendedConfig);
}

function goToFinetuningFromError() {
  const errorOverlay = document.getElementById('errorOverlay');
  if (errorOverlay) errorOverlay.remove();
  goToFinetuning();
}

function showSuccessMessage() {
  const successOverlay = document.createElement('div');
  successOverlay.id = 'successOverlay';
  successOverlay.innerHTML = `
    <div class="success-content">
      <div class="success-icon">✓</div>
      <h3>Erfolgreich gespeichert!</h3>
      <p>Dein Straba startet neu und übernimmt die neuen Einstellungen.</p>
      <p class="success-hint">Dies dauert etwa 10-15 Sekunden.</p>
    </div>
  `;
  successOverlay.style.cssText = `
    position:fixed;top:0;left:0;right:0;bottom:0;
    background:rgba(40,167,69,0.95);display:flex;
    align-items:center;justify-content:center;z-index:9999;
    padding:20px;
  `;

  const style = document.createElement('style');
  style.textContent = `
    .success-content{text-align:center;color:#fff;}
    .success-icon{font-size:64px;margin-bottom:20px;animation:pop 0.5s ease-out;}
    .success-content h3{font-size:24px;margin-bottom:10px;}
    .success-content p{font-size:16px;opacity:0.9;}
    .success-hint{font-size:14px;opacity:0.7;margin-top:15px;}
    @keyframes pop{0%{transform:scale(0)}50%{transform:scale(1.2)}100%{transform:scale(1)}}
  `;
  document.head.appendChild(style);
  document.body.appendChild(successOverlay);

  // Nach 5 Sekunden automatisch schließen
  setTimeout(() => {
    successOverlay.remove();
  }, 5000);
}

// ==================== SAVING OVERLAY ====================
function showSavingOverlay(text) {
  let overlay = document.getElementById('savingOverlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.id = 'savingOverlay';
    overlay.innerHTML = `
      <div class="saving-content">
        <div class="saving-spinner"></div>
        <div class="saving-text">${text}</div>
      </div>
    `;
    overlay.style.cssText = `
      position:fixed;top:0;left:0;right:0;bottom:0;
      background:rgba(0,0,0,0.9);display:flex;
      align-items:center;justify-content:center;
      flex-direction:column;z-index:9999;
    `;
    const style = document.createElement('style');
    style.textContent = `
      .saving-content{text-align:center;color:#fff;}
      .saving-spinner{width:48px;height:48px;border:3px solid #333;
        border-top-color:#0055a4;border-radius:50%;
        animation:spin 1s linear infinite;margin:0 auto 20px;}
      .saving-text{font-size:16px;}
      @keyframes spin{to{transform:rotate(360deg)}}
    `;
    document.head.appendChild(style);
    document.body.appendChild(overlay);
  } else {
    overlay.style.display = 'flex';
    overlay.querySelector('.saving-text').textContent = text;
  }
}

function updateSavingOverlay(text) {
  const overlay = document.getElementById('savingOverlay');
  if (overlay) {
    overlay.querySelector('.saving-text').textContent = text;
  }
}

function hideSavingOverlay() {
  const overlay = document.getElementById('savingOverlay');
  if (overlay) {
    overlay.style.display = 'none';
  }
}

// Legacy-Funktion für Kompatibilität
function sendConfigToDevice(color, rows) {
  if (recommendedConfig) {
    recommendedConfig.colour = color;
    recommendedConfig.rows = rows;
    sendConfigToDeviceDirect(recommendedConfig);
  } else {
    // Fallback für alte Aufrufe
    const rblString = stations.map(s => s.fullId).join(',');
    const filterString = stations.map(s => s.filter || '').join('|');

    localStorage.setItem('straba_pending_rbl', rblString);
    localStorage.setItem('straba_pending_filter', filterString);

    if (window.parent && window.parent !== window) {
      window.parent.postMessage({
        type: 'setConfig',
        rbl: rblString,
        filter: filterString,
        color: color,
        rows: rows
      }, '*');
    }
    window.location.href = 'index.html';
  }
}

// Keep old saveConfig for compatibility
function saveConfig() {
  if (stations.length === 0) return;
  
  const rblString = stations.map(s => s.fullId).join(',');
  const filterString = stations.map(s => s.filter || '').join('|');
  
  localStorage.setItem('straba_pending_rbl', rblString);
  localStorage.setItem('straba_pending_filter', filterString);
  
  // Send to parent (ESP32)
  if (window.parent && window.parent !== window) {
    window.parent.postMessage({ type: 'setConfig', rbl: rblString, filter: filterString }, '*');
  }
  
  window.location.href = 'index.html';
}

// ==================== LOAD EXISTING ====================
// linefilterdestination: Linz-Format "1:Auwiesen,2:solarCity,27:Chemiepark" mit Line:Destination
// roworderdestination: Wien-Format "4A:Karlsplatz U,4A:Wittelsbachstraße,59A:Bhf. Meidling S U" mit Line:Destination
async function loadExistingConfig(rbl, filter, linefilterdestination, roworderdestination) {
  if (!rbl || rbl.trim() === '') return;

  const rblParts = rbl.split(',').map(s => s.trim()).filter(s => s);
  const filterParts = filter ? filter.split('|') : [];

  // Parse linefilterdestination ODER roworderdestination (beide haben gleiches Format)
  // roworderdestination hat Priorität für Wien (enthält die Richtungen)
  const lineDestinations = [];
  const destSource = roworderdestination || linefilterdestination;
  if (destSource) {
    destSource.split(',').forEach(entry => {
      const colonIdx = entry.indexOf(':');
      if (colonIdx > 0) {
        lineDestinations.push({
          line: entry.substring(0, colonIdx).trim(),
          towards: entry.substring(colonIdx + 1).trim()
        });
      }
    });
  }

  for (let idx = 0; idx < rblParts.length; idx++) {
    const part = rblParts[idx];
    let network, stopId;

    if (part.includes(':')) {
      [network, stopId] = part.split(':');
    } else {
      network = 'WL';
      stopId = part;
    }

    const fullId = `${network}:${stopId}`;
    if (stations.some(s => s.fullId === fullId)) continue;

    // Check if it's a journey (has > in stopId)
    const isJourney = stopId.includes('>');
    let stopName = `Station ${stopId}`;

    if (isJourney) {
      const [fromId, toId] = stopId.split('>');
      // Try to get names from API
      const fromName = await resolveStationName(network, fromId) || fromId;
      const toName = await resolveStationName(network, toId) || toId;
      stopName = `${fromName} → ${toName}`;
    } else {
      // Try to get name from API
      const resolvedName = await resolveStationName(network, stopId);
      if (resolvedName) {
        stopName = resolvedName;
      }
    }

    // Filter für diese Station: Liniennamen aus filterParts oder aus lineDestinations
    const stationFilter = filterParts[idx] || '';
    const filterLines = stationFilter ? stationFilter.split(',').map(f => f.trim()) : [];

    // Station erstellen
    const station = {
      network,
      networkName: NETWORKS[network]?.name || network,
      stopId,
      stopName,
      filter: stationFilter,
      fullId,
      isJourney,
      isExisting: true,
      directions: []  // Wird unten befüllt
    };

    // Directions aus API laden (gefiltert)
    try {
      const response = await fetch(`${DEPARTURES_API}?stopId=${fullId}`);
      const data = await response.json();

      if (data.data && data.data.monitors) {
        data.data.monitors.forEach(monitor => {
          if (monitor.lines && Array.isArray(monitor.lines)) {
            monitor.lines.forEach(line => {
              const lineName = line.name || '';
              const towards = line.towards || monitor.towards || '';
              const type = line.type || '';
              const richtungsId = line.richtungsId || monitor.richtungsId || '';

              // Prüfen ob diese Linie+Richtung ausgewählt werden soll
              let shouldInclude = false;

              if (lineDestinations.length > 0) {
                // Linz-Modus: Prüfe gegen linefilterdestination (Line + Destination)
                shouldInclude = lineDestinations.some(ld =>
                  ld.line === lineName && ld.towards === towards
                );
              } else if (filterLines.length > 0) {
                // Fallback: Nur Liniennummer prüfen
                shouldInclude = filterLines.includes(lineName);
              } else {
                // Kein Filter: Alle Linien einschließen
                shouldInclude = true;
              }

              if (shouldInclude) {
                // Duplikate vermeiden
                const exists = station.directions.some(d =>
                  d.line === lineName && d.towards === towards
                );
                if (!exists) {
                  station.directions.push({
                    line: lineName,
                    towards: towards,
                    type: type,
                    richtungsId: richtungsId
                  });
                }
              }
            });
          }
        });
      }
    } catch (e) {
      // API error - station will have empty directions
    }

    stations.push(station);
  }

  if (stations.length > 0) {
    updateStationsList();
  }
}

// Versucht Stationsnamen von API zu holen
async function resolveStationName(network, stopId) {
  try {
    // Für WL können wir die API nicht so einfach nutzen
    if (network === 'WL') {
      // Versuche aus wienData wenn geladen
      if (wienData) {
        for (const line of wienData) {
          if (!Array.isArray(line.lineStation)) continue;
          for (const item of line.lineStation) {
            if (item.station && String(item.station.stationID) === String(stopId)) {
              return item.station.stationName;
            }
          }
        }
      }
      return null;
    }
    
    // Für externe Netze - Departure API nutzen
    const response = await fetch(`${DEPARTURES_API}?stopId=${network}:${stopId}`);
    const data = await response.json();
    
    if (data.data?.monitors?.[0]?.locationStop?.properties?.title) {
      return data.data.monitors[0].locationStop.properties.title;
    }
    
    return null;
  } catch (e) {
    console.warn(`Could not resolve name for ${network}:${stopId}`);
    return null;
  }
}

// ==================== ESP32 COMMUNICATION ====================
async function handleConfigMessage(data) {

  if (data.type === 'loadExistingConfig') {
    // Load Wien data first if any WL stations
    if (data.rbl && !data.rbl.includes(':')) {
      await loadWienData();
    }
    await loadExistingConfig(data.rbl, data.filter, data.linefilterdestination || '', data.roworderdestination || '');
    return;
  }

  if (data.type === 'loadFullConfig' && (data.config?.rbl_id || data.config?.rbl)) {
    // Markiere, dass eine bestehende Config geladen wurde
    hasExistingConfig = true;

    // WICHTIG: Bestehende Stationen löschen, da loadFullConfig vollständigere Daten hat
    // (inkl. linefilterdestination). loadExistingConfig könnte vorher schon
    // mit unvollständigen Daten gelaufen sein.
    stations.length = 0;

    // Unterstütze beide Feldnamen (rbl_id/rbl und lines_filter/filter)
    const rblId = data.config.rbl_id || data.config.rbl || '';
    const linesFilter = data.config.lines_filter || data.config.filter || '';
    const lineFilterDest = data.config.linefilterdestination || '';
    const rowOrderDest = data.config.roworderdestination || '';

    // Load Wien data first if any WL stations
    if (rblId && !rblId.includes(':')) {
      await loadWienData();
    }
    await loadExistingConfig(rblId, linesFilter, lineFilterDest, rowOrderDest);

    // Initialisiere recommendedConfig falls noch nicht vorhanden
    if (!recommendedConfig) {
      recommendedConfig = calculateRecommendedConfig() || {};
    }

    // Linz Linien+Ziel Filter aus Config übernehmen
    if (data.config.linefilterdestination) {
      recommendedConfig.lineFilterDestination = data.config.linefilterdestination;
    }
    // Linien-Gruppierung aus Config übernehmen
    if (data.config.linegroups) {
      recommendedConfig.lineGroups = data.config.linegroups;
    }
    // Sortierungsmodus aus Config übernehmen
    if (data.config.sort_mode !== undefined) {
      recommendedConfig.sortMode = parseInt(data.config.sort_mode) || 1;
    }
    // Zeilen-Reihenfolge aus Config übernehmen
    if (data.config.roworder) {
      recommendedConfig.rowOrder = data.config.roworder;
    }
    if (data.config.roworderdestination) {
      recommendedConfig.rowOrderDestination = data.config.roworderdestination;
    }
    // Weitere Feintuning-Einstellungen
    if (data.config.colour !== undefined) {
      recommendedConfig.colour = parseInt(data.config.colour) || 1;
    }
    if (data.config.lines_count !== undefined) {
      recommendedConfig.rows = parseInt(data.config.lines_count) || 2;
    }
    // displaylight (ESP32 Feldname)
    if (data.config.displaylight !== undefined) {
      recommendedConfig.displayLight = parseInt(data.config.displaylight) || 3;
    }
    // chopper und silberpfeil (ESP32 Feldnamen, als String gesendet)
    if (data.config.chopper !== undefined) {
      recommendedConfig.chopper = parseInt(data.config.chopper) || 0;
    }
    if (data.config.silberpfeil !== undefined) {
      recommendedConfig.silberpfeil = parseInt(data.config.silberpfeil) || 0;
    }
    if (data.config.night_mode_enabled !== undefined) {
      recommendedConfig.nightMode = data.config.night_mode_enabled;
    }
    if (data.config.night_mode_start !== undefined) {
      recommendedConfig.nightStart = parseInt(data.config.night_mode_start) || 22;
    }
    if (data.config.night_mode_end !== undefined) {
      recommendedConfig.nightEnd = parseInt(data.config.night_mode_end) || 6;
    }
    if (data.config.show_fun_messages !== undefined) {
      recommendedConfig.showFunMessages = data.config.show_fun_messages;
    }
    // Gehweg aus Config übernehmen (Format: "stopId:value|stopId:value")
    if (data.config.gehweg) {
      const gehwegStr = data.config.gehweg;
      const gehwegMap = {};

      // Parse "stopId:value|stopId:value" oder "stopId:value,stopId:value"
      const separator = gehwegStr.includes('|') ? '|' : ',';
      gehwegStr.split(separator).forEach(entry => {
        const [stopId, value] = entry.split(':');
        if (stopId && value !== undefined) {
          gehwegMap[stopId] = parseInt(value) || 0;
        }
      });

      // Erstelle Array in der Reihenfolge der Stationen
      recommendedConfig.gehweg = stations.map(station => {
        const stopId = station.stopId || '';
        return gehwegMap[stopId] || 0;
      });
    }

    // UI aktualisieren wenn Feintuning-Seite sichtbar ist
    const ftStep = document.getElementById('stepFinetuning');
    if (ftStep && !ftStep.classList.contains('hidden')) {
      initFinetuningStep();
    }
  }
}

// Event-Listener der die Funktion aufruft
window.addEventListener('message', async function(event) {
  if (event.data?.type === 'loadExistingConfig' || event.data?.type === 'loadFullConfig') {
    await handleConfigMessage(event.data);
  }
});

// Markiere Handler als bereit und verarbeite gepufferte Nachrichten
_configHandlerReady = true;
if (_pendingConfigMessages.length > 0) {
  _pendingConfigMessages.forEach(msg => handleConfigMessage(msg));
  _pendingConfigMessages = [];
}

// ==================== AUTO-RETRY: Config vom Parent anfordern ====================
// Falls nach ein paar Sekunden keine Stationen geladen sind, frage aktiv nach
let _configReceived = false;
let _configRetryCount = 0;
const _maxConfigRetries = 5;

function requestConfigFromParent() {
  if (window.parent && window.parent !== window) {
    window.parent.postMessage({ type: 'requestExistingConfig' }, '*');
    window.parent.postMessage({ type: 'requestFullConfig' }, '*');
  }
}

function checkAndRetryConfig() {
  if (_configReceived || stations.length > 0) {
    return;
  }

  if (_configRetryCount >= _maxConfigRetries) {
    return;
  }

  _configRetryCount++;
  requestConfigFromParent();

  // Nächster Retry in 2 Sekunden
  setTimeout(checkAndRetryConfig, 2000);
}

// Markiere Config als erhalten wenn Stationen geladen werden
const _originalHandleConfigMessage = handleConfigMessage;
handleConfigMessage = async function(data) {
  await _originalHandleConfigMessage(data);
  if (stations.length > 0) {
    _configReceived = true;
  }
};

// Starte Retry-Mechanismus nach 1 Sekunde
setTimeout(checkAndRetryConfig, 1000);

// ==================== JOURNEY MODE (DB) ====================
let journeyFromTimeout = null;
let journeyToTimeout = null;

function showJourneyFromSelected() {
  const input = document.getElementById('journeyFromInput');
  const results = document.getElementById('journeyFromResults');
  const selected = document.getElementById('journeyFromSelected');
  
  if (journeyFromStop) {
    input.parentElement.classList.add('hidden');
    results.classList.remove('show');
    selected.classList.remove('hidden');
    selected.innerHTML = `
      <span class="station-name">${journeyFromStop.name}</span>
      <button class="change-btn" onclick="clearJourneyFrom()">Ändern</button>
    `;
  }
}

function showJourneyToSelected() {
  const input = document.getElementById('journeyToInput');
  const results = document.getElementById('journeyToResults');
  const selected = document.getElementById('journeyToSelected');
  
  if (journeyToStop) {
    input.parentElement.classList.add('hidden');
    results.classList.remove('show');
    selected.classList.remove('hidden');
    selected.innerHTML = `
      <span class="station-name">${journeyToStop.name}</span>
      <button class="change-btn" onclick="clearJourneyTo()">Ändern</button>
    `;
  }
}

function clearJourneyFrom() {
  journeyFromStop = null;
  selectedProducts = new Set();
  const input = document.getElementById('journeyFromInput');
  const selected = document.getElementById('journeyFromSelected');
  const productsSection = document.getElementById('journeyProductsSection');
  
  input.parentElement.classList.remove('hidden');
  selected.classList.add('hidden');
  if (productsSection) productsSection.classList.add('hidden');
  input.value = '';
  input.focus();
}

function clearJourneyTo() {
  journeyToStop = null;
  selectedProducts = new Set();
  const input = document.getElementById('journeyToInput');
  const selected = document.getElementById('journeyToSelected');
  const productsSection = document.getElementById('journeyProductsSection');
  
  input.parentElement.classList.remove('hidden');
  selected.classList.add('hidden');
  if (productsSection) productsSection.classList.add('hidden');
  input.value = '';
  input.focus();
}

async function performJourneyFromSearch(query) {
  const spinner = document.getElementById('journeyFromSpinner');
  const results = document.getElementById('journeyFromResults');
  
  spinner.classList.add('show');
  
  try {
    const searchResults = await searchViaProxy(selectedNetwork, query);
    displayJourneyResults(searchResults, 'from');
  } catch (e) {
    console.error('Journey search error:', e);
    results.innerHTML = '<div class="no-results">Fehler bei der Suche</div>';
    results.classList.add('show');
  } finally {
    spinner.classList.remove('show');
  }
}

async function performJourneyToSearch(query) {
  const spinner = document.getElementById('journeyToSpinner');
  const results = document.getElementById('journeyToResults');
  
  spinner.classList.add('show');
  
  try {
    const searchResults = await searchViaProxy(selectedNetwork, query);
    displayJourneyResults(searchResults, 'to');
  } catch (e) {
    console.error('Journey search error:', e);
    results.innerHTML = '<div class="no-results">Fehler bei der Suche</div>';
    results.classList.add('show');
  } finally {
    spinner.classList.remove('show');
  }
}

function displayJourneyResults(results, type) {
  const container = document.getElementById(type === 'from' ? 'journeyFromResults' : 'journeyToResults');
  
  if (results.length === 0) {
    container.innerHTML = '<div class="no-results">Keine Stationen gefunden</div>';
  } else {
    container.innerHTML = results.map(r => `
      <div class="search-result-item" onclick="selectJourneyStop('${type}', '${r.id}', '${r.name.replace(/'/g, "\\'")}')">
        <div class="stop-name">${r.name}</div>
        <div class="stop-info">${r.info || `ID: ${r.id}`}</div>
      </div>
    `).join('');
  }
  container.classList.add('show');
}

function selectJourneyStop(type, id, name) {
  if (type === 'from') {
    journeyFromStop = { id, name };
    showJourneyFromSelected();
    // Focus auf "Nach" Feld
    if (!journeyToStop) {
      document.getElementById('journeyToInput').focus();
    }
  } else {
    journeyToStop = { id, name };
    showJourneyToSelected();
  }
  
  // Wenn beide Stationen gewählt, zeige Züge
  if (journeyFromStop && journeyToStop) {
    showProductsInline();
  }
}

function showProductsInline() {
  const section = document.getElementById('journeyProductsSection');
  section.classList.remove('hidden');
  
  selectedProducts = new Set();
  renderProductCategories();
}

function renderProductCategories() {
  const netConfig = NETWORKS[selectedNetwork];
  const categories = netConfig.productCategories || {};
  
  // Domestic
  const domesticContainer = document.getElementById('domesticProducts');
  const domesticProducts = categories.domestic?.products || [];
  domesticContainer.innerHTML = domesticProducts.map(p => renderProductOption(p)).join('');
  
  // International
  const intlContainer = document.getElementById('internationalProducts');
  const intlProducts = categories.international?.products || [];
  intlContainer.innerHTML = intlProducts.map(p => renderProductOption(p)).join('');
  
  updateAddJourneyButton();
}

function renderProductOption(product) {
  const selected = selectedProducts.has(product.id);
  return `
    <div class="product-option ${selected ? 'selected' : ''}" onclick="toggleProduct('${product.id}')">
      <div class="checkbox">${selected ? '✓' : ''}</div>
      <div class="product-badge ${product.id.toLowerCase()}">${product.name}</div>
      <div class="product-name">${product.desc}</div>
    </div>
  `;
}

function toggleCategory(categoryId) {
  const content = document.getElementById(categoryId + 'Products');
  const toggle = document.getElementById(categoryId + 'Toggle');
  
  if (content.classList.contains('collapsed')) {
    content.classList.remove('collapsed');
    toggle.textContent = '▼';
  } else {
    content.classList.add('collapsed');
    toggle.textContent = '▶';
  }
}

function toggleProduct(productId) {
  if (selectedProducts.has(productId)) {
    selectedProducts.delete(productId);
  } else {
    selectedProducts.add(productId);
  }
  renderProductCategories();
}

function updateAddJourneyButton() {
  const btn = document.getElementById('addJourneyBtn');
  if (btn) {
    btn.disabled = selectedProducts.size === 0;
  }
}

function addJourneyStation() {
  if (!journeyFromStop || !journeyToStop || selectedProducts.size === 0) return;
  
  const filter = Array.from(selectedProducts).join(',');
  const fullId = `${selectedNetwork}:${journeyFromStop.id}>${journeyToStop.id}`;
  
  // Check duplicate
  if (stations.some(s => s.fullId === fullId)) {
    alert('Diese Verbindung ist bereits hinzugefügt!');
    return;
  }
  
  stations.push({
    network: selectedNetwork,
    networkName: NETWORKS[selectedNetwork].name,
    stopId: `${journeyFromStop.id}>${journeyToStop.id}`,
    stopName: `${journeyFromStop.name} → ${journeyToStop.name}`,
    filter: filter,
    fullId: fullId,
    isJourney: true,
    isExisting: false
  });
  
  // Reset
  journeyFromStop = null;
  journeyToStop = null;
  selectedProducts = new Set();
  
  // Hide products section
  document.getElementById('journeyProductsSection').classList.add('hidden');
  
  goBack('region');
  updateStationsList();
}

// ==================== INIT ====================
window.addEventListener('DOMContentLoaded', () => {
  if (window.parent && window.parent !== window) {
    window.parent.postMessage({ type: 'requestExistingConfig' }, '*');
    window.parent.postMessage({ type: 'requestFullConfig' }, '*');
  }
  
  document.addEventListener('click', (e) => {
    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
      searchResults.classList.remove('show');
    }
    
    // Close journey search results when clicking outside
    const fromInput = document.getElementById('journeyFromInput');
    const fromResults = document.getElementById('journeyFromResults');
    const toInput = document.getElementById('journeyToInput');
    const toResults = document.getElementById('journeyToResults');
    
    if (fromInput && fromResults && !fromInput.contains(e.target) && !fromResults.contains(e.target)) {
      fromResults.classList.remove('show');
    }
    if (toInput && toResults && !toInput.contains(e.target) && !toResults.contains(e.target)) {
      toResults.classList.remove('show');
    }
  });
  
  // Journey From Input
  const journeyFromInput = document.getElementById('journeyFromInput');
  if (journeyFromInput) {
    journeyFromInput.addEventListener('input', function() {
      const query = this.value.trim();
      if (journeyFromTimeout) clearTimeout(journeyFromTimeout);
      
      if (query.length < 2) {
        document.getElementById('journeyFromResults').classList.remove('show');
        return;
      }
      
      journeyFromTimeout = setTimeout(() => performJourneyFromSearch(query), 300);
    });
  }
  
  // Journey To Input
  const journeyToInput = document.getElementById('journeyToInput');
  if (journeyToInput) {
    journeyToInput.addEventListener('input', function() {
      const query = this.value.trim();
      if (journeyToTimeout) clearTimeout(journeyToTimeout);
      
      if (query.length < 2) {
        document.getElementById('journeyToResults').classList.remove('show');
        return;
      }
      
      journeyToTimeout = setTimeout(() => performJourneyToSearch(query), 300);
    });
  }
});
</script>

</body>
</html>
